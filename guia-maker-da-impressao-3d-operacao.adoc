[#guia-maker-da-impressao-3d-operacao]
= Operação da Impressora 3D
:imagesdir: imagens

Uma vez que foi dada a necessária teoria para entender uma impressora 3D atual, a próxima etapa é partir para
a prática. O caso típico de uso a ser tratado em nossos exemplos é o de uma impressora 3D FFF de baixo custo
no mercado nacional para fins pessoais ou profissionais. Alguns modelos de impressoras 3D com características
especiais (como as estilo "delta") serão tratadas em apêndices, assim como casos de uso que extrapolam o comum.

== Introdução

Uma Impressora 3D "de mercado" tipicamente vem com drivers de dispositivo e um software (fatiador) para você
usar com a impressora 3D. No fatiador, você pode controlar a impressão enquanto acontece, ligado à impressora 3D,
ou gerar um arquivo no formato "g-code" para mandar para a impressora quando ela pode ser autônoma, isto é,
tem um "slot" para pendrive ou cartão SD e botões e visor para você iniciar e controlar a impressão sem
nenhum computador conectado.

Como a maior parte do tempo em que você vai passar nas tarefas de impressão 3D será na frente do fatiador,
e como é ele o software que diz como o processo de impressão 3D ocorrerá, é o foco principal deste capítulo.

Existem vários fatiadores diferentes de impressoras FFF no mercado, e muitos fabricantes fazem para seus produtos
fatiadores particulares e específicos, que não servem em outros modelos. Como é um mercado de massa com muitas
alternativas diferentes, qualquer tentativa de tratar esses fatiadores específicos seria improdutiva. O mesmo
pode ser dito de escolher um único fatiador popular como exemplo; o mais popular hoje pode ser obscuro amanhã,
e omitir as inovações e pontos positivos de outros fatiadores faria o aluno ter um aprendizado incompleto.

A abordagem do curso trata, então, de usar como ilustração alguns poucos fatiadores razoavelmente populares,
de boa quantidade de recursos e razoavelmente genéricos, com outros fatiadores (e print hosts) sendo descritos
nos apêndices.

Antes de começar a entender os fatiadores, no entanto, é importante contextualizá-los apropriadamente. Eles se
inserem no workflow de impressão atuando como softwares onde você:

* *Importa* formas tridimensionais (formatos mais comuns: STL, OBJ, AMF e 3MF);
* *Dispõe* essas formas
tridimensionais em uma "bandeja virtual" tridimensional que é a mesa de impressão da impressora 3D que
configurou;
* *Faz operações simples* com essas formas tridimensionais, como: mover as formas; aumentar ou diminuir,
uniformemente ou nos eixos X, Y e Z; realizar cortes simples; rotacionar / inclinar a peça; combinar com outras
peças;
* Grava / exporta a disposição da bandeja que arrumou;
* *Configura* os _parâmetros de fatiamento_
adequados para a forma. Preenchimento, suportes, estruturas de apoio, resolução, etc.;
* *Executa* a operação
de fatiar (geralmente por um botão ou item no menu);
* Tem uma **pré-visualização**, depois do fatiamento
completado, em como ocorrerá a impressão;
* Tem uma *previsão* de tempo e consumo de material da impressão
-- em alguns fatiadores, é até possível colocar o custo por quilo do material para se ter uma **estimativa de preço**;
* Visualiza ou até edita o *g-code* resultante do fatiamento;
* Grava / exporta o g-code resultante;
* Executa operações de manutenção da impressora 3D pela USB, bluetooth ou rede, como testes de movimentação,
gravação de firmware, nivelamento da mesa, mudança de parâmetros da memória do microcontrolador (EEPROM);
* Envia a impressão (g-code) pela USB, bluetooth ou rede para a impressora executar, possivelmente visualizando
a renderização em 3D da trajetória da impressão enquanto ela ocorre;
* Monitora a impressão tendo momento a
momento a temperatura de cada componente aquecido, o material gasto, a velocidade atual, a trajetória percorrida
e até a visualização por câmeras, vendo na tela "ao vivo" enquanto acontece, e podendo até configurar alarmes.

Essas são as opções disponíveis em fatiadores modernos, atualmente. Nenhum deles faz *todas* as operações,
apenas subconjuntos delas. É possível que no futuro agreguem ainda mais funções, e no passado muitas dessas
operações eram realizadas por softwares diferentes. Quando o software não executa a operação de "fatiamento"
mas permite que você controle a impressora, execute operações de manutenção e envie o g-code, ele é chamado de
__**Print Host**__ ao invés de fatiador. Quando o software só recebe o modelo da bandeja pronta e as configurações
de fatiamento como parâmetro, sem mesmo exibir uma interface gráfica, e devolve apenas o "g-code", ele é
chamado de __**fatiador puro**__. Há muita utilidade em se usar um fatiador puro, uma delas é poder ser usado com
outras interfaces e workflows, ou de forma automática e em lote (__batch__) para várias peças e/ou bandejas
pré-configuradas. Ainda, esses fatiadores purs não precisam de recursos de display pra serem executados, podendo
usar o processamento de dispositivos embarcados. Por isso alguns fatiadores, como _Cura,_ _Slic3r_ e _MatterControl_
(não por acaso justamente os open-source), oferecem a funcionalidade de fatiador puro como um opcional do programa
(você pode invocá-los em modo _batch_ pela linha de comando ou através de outro programa).

[[curanofreecad]]
image::curanofreecad.png[curanofreecad,width=626,height=475,align="center",title="O Cura traz consigo o CuraEngine, um executável para que ele possa ser usado como fatiador puro. Deste modo, outros softwares como Repetier Host e FreeCAD podem invocá-lo. No screenshot vemos a bancada de impressão 3D do FreeCAD pronta pra chamar o CuraEngine."]

== Fluxo de trabalho (workflow) da Impressão 3D

* **Escolha ou obtenção das formas tridimensionais**. Há diversas fontes possíveis para as formas:
** Elas podem ser criadas por softwares __**modeladores sólidos**__ -- aplicativos que permitem a modelagem tridimensional e
geram arquivos cujos dados descrevem as formas sólidas que compõem o modelo. Alguns exemplos de tais softwares:
SolidWorks, Inventor, FreeCAD.
** Elas podem ser criados por software _*modeladores de malha ou superfície*_
-- aplicativos que permitem a modelagem tridimensional e geram arquivos cujos dados, ao invés de descrever
as formas sólidas que compõem o modelo, descrevem as superfícies ou "peles" que envolvem as formas do
modelo. A diferença aparentemente sutil de abordagem é gigante no que concerne aos dados gravados e como são
processados matematicamente. Em geral os modeladores de superfície geram formas mais orgânicas, como fazem
os aplicativos ZBrush, Sculptris e Blender mas também o Sketchup.
** *Modeladores matemáticos* de funções
algébricas podem gerar formas de gráficos tridimensionais, também em malha, como Mathematica e MathCAD;
** **Linguagens de programação em 3D**, como CadQuery, OpenSCAD, SolidPython;
** Digitalização 3D de imagens
(por fotogrametria, por scanner 3D especializado, por ultrassom "4D")
** **Procura e download da Internet**,
em sites de impressão 3D como _thingiverse_ ou __youmagine__, sites genéricos de formas 3D como _grabcad_
e _cgtrader_ ou até mecanismos de busca 3D como __yobi3d__, _stlfinder_ e __yeggi__.
** Extração de dados
de aplicativos e jogos, através de "desempacotadores" e conversores automáticos. Um exemplo notável é o
jogo _minecraft_ que tem muitos modelos extraídos para impressão, mas virtualmente qualquer jogo tridimensional
tem seus modelos conversíveis para as malhas impressas em 3D (e como as formas não são feitas especificamente
para impressão 3D, podem precisar de alguns ajustes).
** Personalização e geração de objetos, em sites como
_thingiverse_ (novamente) ou geradores de "lithopanes" (fotografias bidimensionais em relevo).
* *Conversão*
da forma para um formato que o fatiador entenda. Para malhas simples de uma só cor, STL e OBJ; para malhas com
cores ou materiais diferentes, AMF ou 3MF;
* *Importação* da forma 3D no fatiador, de onde se procede com o
**workflow do fatiamento**;
* Preparação física da impressora para a operação: inserção do filamento no
extrusor, colocação do vidro na mesa aquecida, revestimento do vidro com fita ou cola;
* *Envio da impressão*
para a Impressora 3D, seja por um dispositivo intermediário de armazenamento (cartão SD, pendrive -- de onde
se escolhe o arquivo em um display da impressora), seja por uma conexão entre impressora e computador (wifi,
ethernet, cabo USB, bluetooth);
* A Impressão de uma peça média (5-10cm de altura) em uma FFF tipicamente leva
horas para concluir. Mesmo com essa demora, se recomenda altamente o **acompanhamento presencial das impressões**,
especialmente se a impressora não tiver segurança industrial de operação, como peças resistentes ao fogo,
câmara fechada, resistência a impactos mecânicos;
* Finalizada a impressão, há uma etapa de **retirada da impressão da mesa**, que pode dar algum trabalho;
* Retirada a peça, pode haver a necessidade de **remoção de estruturas de apoio**, como a bainha, os suportes, o raft;
* A peça pode precisar ou se beneficiar de uma etapa
adicional de **acabamento**: lixagem, remoção de pontas e plástico residual, pequenos reparos; peças divididas
serão coladas; para alguns plásticos, temos a opção de **acabamento químico**, usando solventes como acetona
ou clorofórmio;
* Opcional: *revestimento* da peça para conferir a ela alguma propriedade como dureza ou brilho;
* Opcional: *pintura* da peça para lhe dar cores e "vida".

[[fluxodeimpressao3d]]
image::fluxodeimpressao3d.png[fluxodeimpressao3d,width=1270,height=1446,align="center",title="Parte do workflow de impressão 3D: 1. Obtenção de uma forma 3D, sólida ou malha; 2. preparação da forma para malha e exportação para STL; 3. Importação e disposição das peças na bandeja virtual para fatiamento; 4. Após o fatiamento, visualização (parcial) de como a estrutura ficará impressa; 5. O início do g-code resultante deste fatiamento, com realce de sintaxe."]

== E o que é fatiar?

A etimologia da palavra já revela sua fundamentação: vamos pegar uma forma 3D, orientar em relação a uma
superfície, e cortá-la em fatias horizontais (seções transversais) bem finas, como se fosse um pão de forma
colocado na vertical.

Quanto mais finas as fatias, menos os detalhes verticais nelas importam (como inclinações), pois mais ela se
aproxima de algo perfeitamente bidimensional. Com fatias de paredes simplificadas suficientemente finas e um
número muito grande delas, seu empilhamento será praticamente igual à figura tridimensional que as originou.

[[lulafatiado]]
image::lulafatiado.png[lulafatiado,width=608,height=510,align="center",title="Uma figura cortada em dezenas de fatias para impressão 3D. Cada fatia tem uma seção transversal cuja área interna é transformada em uma trajetória que a cabeça de impressão percorrerá para cobrir toda aquela área, depositando o filete de plástico, e empilhando sucessivas camadas começando da mais baixa, em contato com a superfície, até a mais alta."]

O profissional abre o software fatiador e o alimenta com a peça ou peças tridimensionais (arquivos digitais como
STL, AMF, 3MF, OBJ) que deseja imprimir, as visualizando na interface e as dispondo em uma "bandeja virtual",
que representa a plataforma de impressão da máquina a ser usada. O operador toma as _decisões_ que mencionamos,
como a altura de cada fatia ("altura de camada"), além de algumas operações simples de manipulação 3D
como rotacionar, mudar o tamanho ou até cortar e separar a forma. Após a operação matemática de fatiamento
ser completada, o fatiador devolve um código de máquina que a impressora 3D entende e executa. Este código,
normalmente no formato "G-Code", pode ser gravado em mídia como cartão SD ou pendrive e colocado na impressora,
ou ser enviado a ela -- dependendo do modelo, por uma porta USB, bluetooth ou rede sem fio.

Fica mais fácil ver com o resultado da visualização de algumas camadas do fatiamento da Figura 15:

[[sequenciacamadas]]
image::sequenciacamadas.png[sequenciacamadas,width=642,height=475,align="center",title="Sequência de camadas escolhidas semi-aleatoriamente de baixo para cima da bandeja com três elementos; o preenchimento interno da peça aparece em azul, o perímetro em vermelho. À direita de cada quadro, temos uma régua com a altura em que é impressa."]

[[curaprinthost]]
image::curaprinthost.png[curaprinthost,width=662,height=269,align="center",title="Cura (versão antiga) controlando uma impressão enquanto acontece. O gráfico mostra as temperaturas do extrusor e da mesa aquecida de acordo com o tempo."]

== Fatiadores

A seguir, uma listagem atual dos principais fatiadores de impressão 3D FFF disponíveis para microcomputadores
(PC/Mac).

* *Slic3r* -- fatiador open-source com muitos recursos avançados e opções de configuração;
escrito em perl, sua velocidade de fatiamento às vezes decepciona. Se destacam nele a possibilidade
de cortar peças no próprio fatiador, a possibilidade do uso de arcos, retração de firmware e
autospeed. Plataformas: Mac OS X, Linux, Windows. Sítio oficial em http://slic3r.org/[_http://slic3r.org_]
e código em https://github.com/alexrj/Slic3r[_https://github.com/alexrj/Slic3r_].
* *Prusa Slic3r* -- fork mais famoso do Slic3r feito pela Prusa Research, com
"polimento" extra, alguns recursos a mais e cuidado extra com defaults. Anúncio e explicação
http://www.prusaprinters.org/introducing-slic3r-prusa-edition/[_http://www.prusaprinters.org/introducing-slic3r-prusa-edition/_],
downloads em https://github.com/prusa3d/Slic3r/releases[_https://github.com/prusa3d/Slic3r/releases_] e código
em https://github.com/prusa3d/Slic3r/[_https://github.com/prusa3d/Slic3r/_].
* *Cura* -- fatiador open-source
com duas versões bem diferentes: a antiga, até a versão numerada como 15.04.3, com interface bem simples,
intuitiva e ágil, assim como fatiamento bem rápido, mas com poucas opções de configuração; e a nova, tendo
sua interface reescrita e começando da versão 2.1.0, com muito mais opções de configuração e recursos
avançados e únicos, como "penugem" e impressão em arame. Plataformas: Mac OS X, Linux, Windows. Existem
versões "personalizadas" (forks) do Cura feitos por terceiros, como o "Lulzbot Cura", o "Katana" e
até uma versão que funciona como fatiador de impressora SLA ao invés de FFF (Cura da CTC Riverside). Sítio
oficial em https://ultimaker.com/en/products/cura-software[_https://ultimaker.com/en/products/cura-software_],
código em https://github.com/Ultimaker/Cura[_https://github.com/Ultimaker/Cura_].
* *MatterControl* --
fatiador open-source escrito em .Net, se ressaltando pelos plug-ins (braille, importação de imagens 2D,
criação de texto 3D) e pelo workflow bem controlado, permitindo operações em batch, oferecendo alarmes de
e-mail ou SMS e monitoração remota da impressora. Tem uma quantidade média de opções. Plataformas: Mac
OS X, Linux, Windows. Sítio web em http://www.mattercontrol.com/[_http://www.mattercontrol.com/_], código em
https://github.com/MatterHackers/MatterControl[_https://github.com/MatterHackers/MatterControl_].
* *Simplify3D*
-- fatiador proprietário vendido por US$ 150 pela empresa de mesmo nome. Tem muitos recursos avançados e uma
boa quantidade de opções de configuração, além do workflow bem controlado pelo que chama de "processos"
e "perfis". Se destacam nele a colocação personalizada de suportes, o fatiamento rápido e para vários
formatos, o painel de controle da impressora poderoso e com autodetecção de protocolo, a visualização
seccional das peças e o nivelamento fácil de peças na mesa. Plataformas: Mac OS X, Linux, Windows. Sítio
web em http://www.simplify3d.com/[_http://www.simplify3d.com_].
* *Kisslicer* -- fatiador _shareware_ já
não muito atualizado, caracterizado pelo bom fatiamento de superfície, edição online do g-code, versão para
raspberry pi e alguns recursos únicos como __seam hiding__. Extrusão dupla ou tripla só é possível na versão
registrada. Plataformas: Mac OS X, Linux, Windows. Sítio web em http://www.kisslicer.com/[_http://www.kisslicer.com_].
* *Voxelizer* - fatiador proprietário gratuito da empresa Zmorph, bastante poderoso e trabalhando em um
workflow que antes converte as formas em "voxels", ou pixels tridimensionais. Dotado de recursos poderosos,
como fatiagem adaptativa (diferentes alturas de camada para diferentes partes do objeto) e muito parâmetros
de configuração. Funciona para impressoras 3D FFF genéricas mas é especialmente criado para as impressoras
sofisticadas da Zmorph, especialmente as multifuncionais. Plataformas: principalmente Windows, versões de Mac OS X e
Linux existem mas estão muito defasadas. Sítio web em http://voxelizer.com/welcome/[_http://voxelizer.com/welcome/_].
* *CraftUnique Craftware* -- fatiador proprietário gratuito com um visual e workflow bem distintos; tem um número
médio de configurações ao mesmo tempo em que apresenta recursos bem poderosos, como a _colocação personalizada
de suportes_ e a visualização simultânea de g-code de seções. Plataformas: Mac OS X, Linux, Windows. Sítio
web em https://craftunique.com/craftware[_https://craftunique.com/craftware_].
* *Repsnapper* -- apesar de
bastante negligenciado, esse fatiador open-source multiplataforma simples continua em desenvolvimento ativo e tem
alguns recursos interessantes, como uma parte de controle da impressora bem completa com macros e editor de g-code,
fatiamento para SVG, corte e separação interativa de partes de STL, velocidade separada para Z, fatiamento variável,
velocidade de overhang configurável, raio de largura de camada para diâmetro do bico configurável, importação
e exportação para AMF, geração de arcos (G2 e G3), compensação horizontal ("offset outer shells"), e
renderização tridimensional que não necessita de aceleração (sendo interessante para uso em embarcados), opções
de depuração detalhadas para achar erros e equivalências em G-Code (este último recurso o torna o melhor fatiador
para usuários avançadíssimos e desenvolvedores que precisam depurar novos recursos de firmware). Plataformas: Mac OS
X, Linux, Windows. Código em https://github.com/timschmidt/repsnapper[_https://github.com/timschmidt/repsnapper_].
+
image:image267.png[image,width=506,height=348]
+
* *IceSL* -- fatiador _experimental_
que é uma espécie de mistura de "OpenSCAD" com Slic3r, feito inicialmente pra fins
acadêmicos. Multiplataforma, mas infelizmente não é open-source, o que é especialmente lamentável
pois se fosse teria muito apelo pra crescer, conseguindo fazer formas complexas sem perder detalhes
por interpolação, consegue lidar com extrusão dupla de maneira admirável e tem também um primoroso
algoritmo de contorno para __warp shield__. Tem duas versões online totalmente usáveis. Sítio web em
https://members.loria.fr/Sylvain.Lefebvre/icesl/[_https://members.loria.fr/Sylvain.Lefebvre/icesl/_].
* *Raise3D IdeaMaker* -- fatiador bem novo, tem aparência e recursos muito parecidos com o Simplify3D (incluido os suportes
manuais) mas é gratuito. Se destaca pela interface limpa e pelo recurso de corte de peças por planos (incluindo
planos inclinados). Sítio web em https://www.raise3d.com/pages/ideamaker[_https://www.raise3d.com/pages/ideamaker_]

Temos ainda softwares que não são fatiadores completos, mas __print hosts__:

* **pronterface/suite Printrun**:
um controlador de impressão open-source escrito em python com interface compacta, poderosa e ágil, muito usado para
diagnósticos e resolução de problemas avançados em impressoras 3D. Permite usar o Slic3r como fatiador puro.  *
**Repetier Host**: um controlador de impressão proprietário escrito em .Net sofisticado, com bandeja virtual para
colocação das peças, operações reversíveis de zoom/escala/rotação com as formas, integração com fatiadores
Slic3r e Cura, ótima integração com impressoras 3D que usem o _Repetier Firmware_ e o servidor de impressão
_Repetier Server,_ com visualização e edição de g-code, e poderosa interface de controle da impressora 3D.
* **Atelier**: controlador de impressão open-source com grande participação brasileira no desenvolvimento,
escrito em C++ com a biblioteca gráfica Qt.

[[variosfatiadores]]
image::variosfatiadores.png[variosfatiadores,width=589,height=546,align="center",title="Populares fatiadores e print hosts. Na sequência: Slic3r, Cura, MatterControl, Simplify3D, Kisslicer, Voxelizer, Craftware, Pronterface, Repetier Host"]

Trabalharemos com 3 fatiadores e um Print Host para comparação: os open-source *Slic3r* e **Cura**, o proprietário
gratuito *Repetier Host* e o proprietário pago **Simplify3D**. Esses softwares foram escolhidos tanto por sua
popularidade, tanto pelos seus termos serem, em comparação, facilmente transferíveis para as opções dos
outros fatiadores. É importante notar que mais que aprender "caixinhas" e "diálogos" de um fatiador, é
essencial entender os conceitos por trás; o mercado muda, e o fatiador que hoje é popular pode se tornar esquecido
em alguns anos. A monocultura de aplicações infelizmente é um "vírus mental" que assola muitos campos do
conhecimento e os prejudica trazendo esta confusão de conceitos entre o "método" e a "ferramenta". Para
piorar o cenário, as empresas produtoras dos softwares das "monoculturas" comumente os vendem sob licenças
proprietárias, restritivas e controladoras, para estender o poder sobre os profissionais e sedimentar seu domínio
-- pode se tornar impossível exercer aquela profissão sem o aval da fabricante, um poder inadmissível que
muitos entregam sem hesitação (condenando junto os colegas de profissão, pelo efeito de rebanho).

== Aprendendo a fatiar: configuração inicial

Comecemos por ver os primeiros parâmetros, os mais básicos que precisaremos, para configurar a nossa impressão
em um fatiador de mercado. O assistente de configuração do fatiador __Slic3r__, especificamente, pede justamente
as configurações iniciais que nos interessam, e usaremos como ilustração passando em seguida em como esses
ajustes aparecem nos outros fatiadores.

[[slic3rwelcome]]
image::slic3rwelcome.png[slic3rwelcome,width=628,height=328,align="center",title="Assistente de configuração de primeira execução do Slic3r."]

=== Ajuste I: Tipo de código de máquina

Existem muitas impressoras 3D no mercado, e embora a maioria delas use uma variação do *G-Code* consagrado
de décadas de uso em máquinas CNC, pequenas variações podem gerar grandes diferenças, como um código de
inicialização inadequado. Escolher o "sabor" (flavor) do código aceito pelo seu firmware é extremamente
importante. Consulte o manual da sua impressora 3D para saber o _firmware_ que ela usa. Nas estilo reprap, os
firmwares mais usados são o __Marlin__, o _Repetier Firmware_ e em um longínquo terceiro lugar, o __Sailfish__.

Note-se ainda que essa configuração não deve ser confundida com outra: o formato de arquivo a ser gravado. Algumas
impressoras, como as da Makerbot, aceitam g-code em um "modo de compatibilidade" mas têm um formato binário
nativo próprio (de nome S3G, Sanguino3 G-code, e extensão .s3g ou .x3g) que alguns poucos fatiadores suportam
(em nosso exemplo, somente o Simplify3D), tendo os outros que recorrer a um software conversor posterior (gpx)
que transforma o arquivo .gcode em .x3g.

[[ajuste1codigomaquina]]
image::ajuste1codigomaquina.png[ajuste1codigomaquina,width=637,height=436,align="center",title="Escolhas de sabores de firmware do Slic3r. A última, &quot;no extrusion&quot;, significa que ele só vai criar um arquivo de movimentos, sem deposição de plástico. É uma opção interessante para testes de funcionamento."]

=== Ajuste II: tamanho e formato da mesa

Este ajuste varia um pouco entre os fatiadores: em alguns deles você entra apenas os lados da mesa, em outros
você entra as três dimensões X, Y e Z do seu volume de impressão. No Slic3r, você entra apenas os lados e
a altura máxima fica "em aberto", você podendo colocar objetos de qualquer altura na mesa virtual dele. Ele
também permite que você defina um ponto da mesa para ser a "origem", ou seja, o ponto onde as coordenadas são
zero. Se você entrar as dimensões 200 mm x 200 mm para a mesa e colocar o ponto (100,100) como sendo a origem,
estará informando ao Slic3r que o centro da mesa é (0,0), e ele gerará as coordenadas do G-code de acordo
com essa configuração. Via de regra, mesas retangulares têm o (0,0) no canto inferior esquerdo, que já é o
__default__. Geralmente só se muda esse default no caso de algumas impressoras 3D estilo delta que usam mesa quadrada.

As deltas em sua grande maioria no entanto usam mesas circulares (ou hexagonais, mas com áreas de impressão
aproximada de um círculo), e você pode selecionar esta opção no Slic3r -- e aí a origem é obrigatoriamente
no centro da mesa.

O Slic3r oferece ainda uma terceira possibilidade de você usar um arquivo STL para definir a forma da mesa.

[[ajuste2bedsizerectangular]]
image::ajuste2bedsizerectangular.png[ajuste2bedsizerectangular,width=636,height=331,align="center",title="Configuração de mesa retangular no Slic3r, com a possibilidade de definir a origem."]

[[ajuste2bedsizecircular]]
image::ajuste2bedsizecircular.png[ajuste2bedsizecircular,width=636,height=331,align="center",title="Mesa circular (comumente usada em deltas)"]

Vale notar, finalmente, que especialmente quem usa a impressão 3D para serviços de impressão sob demanda pode
se beneficiar de um "truque" que é criar configurações especiais de impressoras com "mesas virtuais"
gigantes -- digamos, 2000 mm x 2000 mm de área -- somente para poder dispor todos os modelos de uma só vez e
ter uma estimativa do tempo total e volume de plástico gasto de uma quantidade grande de peças .

=== Ajuste III: diâmetro do (orifício do) bico

Lembre-se: o _bico_ é o __nozzle__, a pecinha pequena de onde o plástico sai derretido, não é o
__hotend__. Portanto deve ficar bem evidente que sempre que falarmos em diâmetro do _bico_ estamos falando do
diâmetro __de saída__, do filete bem fino que será depositado na mesa. Os bicos mais usados hoje em dia têm
abertura de 0,4mm, mas você deve verificar o manual da sua impressora para saber esse número. A maioria das
impressoras também oferece o bico como uma peça trocável, encaixável no bloco aquecedor por uma rosca M6
(6mm de diâmetro) comum, permitindo com essa padronização que o usuário use suas impressoras com diferentes
diâmetros de bico.

[[ajuste3ondemedir]]
image::ajuste3ondemedir.png[ajuste3ondemedir,width=356,height=282,align="center",title="É isto que buscamos."]

O fatiador usará este número para saber qual é a espessura do filete que ele deposita. Se ele for preencher um
quadrado de 1,2mm x 1,2mm com um bico de 0,4mm, por exemplo, ele fará 3 linhas paralelas (3 x 0,4 = 1,2) de 1,2mm
de comprimento cada.

[[ajuste3diametrodobico]]
image::ajuste3diametrodobico.png[ajuste3diametrodobico,width=642,height=304,align="center"]

=== Ajuste IV: diâmetro do filamento

Aqui ocorre uma confusão comum: o _hotend_ da sua impressora 3D tem um tubo interno que ou é preparado para
filamentos de 1,75mm, ou é preparado para filamentos de 3mm. Este tubo será um pouco maior que o diâmetro nominal
do filamento, tanto para acomodar variações de filamentos quanto certa expansão térmica que irá acontecer, sem
ficar tão folgado que dê para o filamento dobrar. Então o tubo de um hotend preparado para 3mm terá, digamos,
3,1mm de diâmetro. Por outro lado, os próprios filamentos costumam ter o contrário desta folga: são fabricados
com o diâmetro _um pouco abaixo_ do nominal, pelos mesmos motivos. Um filamento vendido como "1,75mm" terá
normalmente algo por volta de 1,7mm, e um de 3mm variará em torno dos 2,85mm. Essas medidas podem ainda variar
mais dependendo do fabricante e até do lote de filamento.

Esse ajuste, no entanto, é muito importante para o fatiador calcular o quanto de material estará utilizando. É
a área da seção transversal do filamento vezes o comprimento que dá o volume de plástico que entra; coloque
um diâmetro menor que o realmente utilizado, e terá superextrusão; coloque um diâmetro maior, e terá
subextrusão. Essas duas situações são problemáticas. Uma recomendação que se costuma fazer é medir o
filamento em vários pontos e fazer uma média, e refazer a medida cada vez que se trocar o carretel de filamento
(os fatiadores permitem vários perfis de configuração de filamento).

[[paquimetrodiametrofilamento]]
image::paquimetrodiametrofilamento.jpeg[paquimetrodiametrofilamento,width=412,height=383,align="center",title="Esse instrumento de medida chama-se paquímetro, &quot;caliper&quot; em inglês. Com ele medimos o diâmetro do filamento que entra no extrusor da foto."]

[[ajuste4diametrofilamento]]
image::ajuste4diametrofilamento.png[ajuste4diametrofilamento,width=634,height=300,align="center"]

[NOTE]
.Nota:
====
Cabe lembrar que os filamentos de impressão 3D de 3mm hoje em dia estão em desuso. Se o leitor procura comprar uma impressora 3D nova, privilegie modelos compatíveis com filamento de 1,75mm.
====

=== Ajuste V: temperatura do extrusor

Como no caso do diâmetro do filamento, este é só um ajuste inicial; você irá criar vários perfis diferentes
posteriormente, por exemplo um para ABS, outro para PLA. No caso ilustrado, consideramos que vamos inicialmente
usar ABS, então configuramos a temperatura do extrusor em 230°C.

[[ajuste5temperaturadoextrusor]]
image::ajuste5temperaturadoextrusor.png[ajuste5temperaturadoextrusor,width=635,height=301,align="center"]

=== Ajuste VI: temperatura da mesa

Este parte terá uma leve variação entre fatiadores pois alguns oferecem um "checkbox" para você dizer
se a impressora tem ou não mesa aquecida, e somente se estiver ligado permitem configurar uma temperatura. No
caso do Slic3r, se sua impressora 3D não tiver mesa aquecida, ou se tiver mas o material não necessitar dela
aquecida, basta colocar zero no campo. No nosso caso, usaremos ABS com um vidro acima da mesa, portanto usaremos
a temperatura-padrão de 120°C pra que a primeira camada fique acima da temperatura de transição vítrea. A
recomendação do Slic3r de 110° é adequada para mesas sem vidro. Note que algumas impressoras 3D podem não ter
potência suficiente para chegar a 120°C na mesa, caso em que a única saída é colocar um valor menor neste campo.

[[ajuste6temperaturadamesa]]
image::ajuste6temperaturadamesa.png[ajuste6temperaturadamesa,width=634,height=300,align="center"]

Terminamos a configuração inicial, e agora estamos prontos para usar o software!

image::image279.png[image,width=634,height=300,align="center"]

== Revendo a configuração

Mas não acabou -- após a primeira execução, o assistente pode ser chamado novamente pelo item "Help" →
"Configuration Assistant"; mas é útil saber onde estão as configurações. A interface que aparece logo
após o assistente é essa:

[[interfaceinicialslic3r]]
image::interfaceinicialslic3r.png[interfaceinicialslic3r,width=616,height=453,align="center",align="Interface inicial do Slic3r"]

Faremos uma modificação nas configurações gerais. O Slic3r inicia em "modo novato" (novice mode), em
que apenas as configurações mais simples são exibidas. Como queremos saber todas, vamos mudar para o modo
"Expert". Vá em "File" → "Preferences":

[[opcoesdefaultslic3r]]
image::opcoesdefaultslic3r.png[opcoesdefaultslic3r,width=248,height=278,align="center",title="Opções iniciais (default) das preferências gerais do Slic3r"]

Vamos mudar "Simple" para "Expert". Para facilitar nossa operação, vamos também marcar a opção
"Remember output directory" para que ele lembre onde estamos gravando nossos arquivos ".gcode", que
enviaremos para a impressora 3D. A opção "Auto-center parts", quando ativada, faz com que ao abrirmos as
peças 3D para dispor em nossa bandeja virtual, ele automaticamente rearranje as peças para ficarem centralizadas,

Vamos também desabilitar o "background processing", e essa opção exige entender um pouco com o Slic3r, em
particular, funciona. Ele foi um dos primeiros fatiadores a surgir do projeto reprap, sucedendo espiritualmente um
anterior chamado "skeinforge" (que não é mais usado). Para facilitar o ritmo do desenvolvimento e o ingresso
de voluntários no projeto (lembre-se, ele é open-source e colaborativo), ele foi escrito em uma linguagem de
programação mais fáceis de usar e com mais recursos matemáticos disponíveis -- perl -, no entanto a linguagem
tem o ponto baixo de ter baixo desempenho e alto uso de memória. Hoje em dia grande parte desse problema foi sanado
e o perl é na verdade escrito em perl e C, com as partes que mais precisam de desempenho terem sido convertidas
pra linguagem mais rápida "C", mas ele ainda é visivelmente mais lento na operação de fatiar do que outros
fatiadores como Simplify3D e Cura.

O __background processing__, ou processamento de fundo, dispara o refatiamento a qualquer modificação feita
nas configurações ou nas posições das peças na bandeja virtual. Sabendo que esse processamento demora e
sobrecarrega o computador, isso pode não ser uma boa idéia. Desmarcando essa opção, o fatiamento só será
disparado quando realmente necessário, ou seja: quando o arquivo .gcode for ser gravado ou quando o botão
"print" for pressionado para controlar a impressão pela USB.

O botão "Print" só aparece, por sua vez, se a conexão "serial" (USB) da impressora for
configurada. Desmarcar a opção "Disable USB/serial connection" faz com que o slic3r possa exercer a função de
_host_ ou _controlador_ de impressão, ou seja, possa controlar a impressora pela USB e enviar automaticamente G-Code
para ela, tendo que ficar ligado durante todo o andamento da impressão. Fora os fatiadores que já mencionamos,
existem softwares que exercem somente o papel de host, como Repetier Host, Pronterface e Atelier; antigamente
o Slic3r não tinha as funções de host e o Repetier Host era bastante usado para gerenciar suas impressões,
pois sua interface é bastante sofisticada e completa para esse fim.

Alguns fatiadores e hosts, quando iniciados pela primeira vez, vasculham automaticamente as conexões seriais do
computador para ver se há uma impressora conectada e tentam uma autodetecção de parâmetros e modelos. O Slic3r,
por segurança, não faz isso.

O workflow de impressão irá variar bastante se você a gerencia pelo fatiador ou não. Vantagens de usar um
controlador de impressão:

* Você não precisa estar com a impressora 3D nem mesmo próxima; basta estar ligada pela USB ao computador. Não
precisa gravar e transportar pen drive ou SD Card até ela;
* O andamento da impressão é claramente mostrado no
fatiador, com a seção sendo impressa aparecendo na tela em tempo real, de forma que fica muito intuitivo entender
o que está acontecendo.

Há desvantagens também:

* A velocidade de transferência pela USB é velocidade de __serial__, o que quer dizer que é muito baixa --
geralmente 115200 bps e no máximo 225000, velocidade dos _modens_ de 1995. É suficiente para conduzir a impressão
3D em tempo real, mas se a operação for transferir o arquivo .gcode para a impressora, a tendência é demorar.
* A impressão fica totalmente dependente do computador e o ocupando. Se o computador estiver com sobrecarga de
processamento e travando, a impressão sofrerá pausas que prejudicarão a qualidade de impressão; se ele der
alguma pane ou o fatiador fechar, a impressão terminará. E você não poderá sair do software de impressão
até a impressão 3D terminar, o que tipicamente leva várias horas para uma peça média.

Aprenderemos os dois modos aqui. Vamos deixar o fatiador configurado para poder controlar a impressora pela USB,
que é o modo mais geral. Vamos desselecionar o __disable__. Nossa configuração final das preferências ficará assim:

[[slic3rdefaultpraexpert]]
image::slic3rdefaultpraexpert.png[slic3rdefaultpraexpert,width=284,height=377,align="center",title="Como deverão ficar nossas preferências: modo Expert, lembrar diretório de saída, auto-centralizar, desabilitamos processamento de fundo e também permitimos conexão serial."]

Confimando a seleção, o Slic3r nos pede que reiniciemos:

[[slic3rwarningreinicio]]
image::slic3rwarningreinicio.png[slic3rwarningreinicio,width=336,height=117,align="center"]

Saia do software e o chame novamente. Você perceberá uma nova aba, "Controller". Se clicar nas outras abas,
verá que em relação ao modo simples agora aparecem bem mais opções, divididas por seções laterais.

Vamos aproveitar e já configurar a impressora 3D para ser reconhecida pela USB. Clique na aba "Printer settings".

[[slic3rserialprinthost]]
image::slic3rserialprinthost.png[slic3rserialprinthost,width=589,height=568,align="center",title="Agora temos a aba &quot;controller&quot; por termos permitido conexão serial e como estamos no modo expert o painel com categorias à esquerda aparece. Não se assuste com a quantidade de opções: a grande maioria delas pode ser deixada no default e com o tempo e prática você irá aprendendo quando houver necessidade de mudar as mais complexas. Podemos reconhecer duas opções da impressora que já configuramos na execução inicial nessa aba, a &quot;forma da mesa&quot; e o &quot;sabor de G-code&quot;, ressaltados na figura."]

O ajuste de "Extruders" permite que o slic3r lide com mais de um extrusor, para impressões com dois ou mais
materiais simultâneos. E o "octoprint" é um software open-source que roda um servidor de impressão, ou seja,
um software que permite que você envie tarefas de impressão e as monitore pela rede. O Cura também permite tal
conectividade com o octoprint.

Vemos que existe um espaço para "serial port" nos ajustes que está em branco. Esta "porta
serial" é o dispositivo de comunicação com a impressora 3D (o cabo USB), e precisa de um
_driver_ para funcionar corretamente. Ele varia de acordo com o sistema operacional. No Linux,
ele já é integrado ao sistema e reconhecido automaticamente, não precisando de nenhuma ação
adicional. No Windows e Mac OS X, para essa porta ser corretamente reconhecida, é necessário a
instalação de um driver USB-pra-serial. Um endereço de web para baixar tais drivers é o seguinte:
http://www.silabs.com/products/mcu/Pages/USBtoUARTBridgeVCPDrivers.aspx[_http://www.silabs.com/products/mcu/Pages/USBtoUARTBridgeVCPDrivers.aspx_]

No Windows, para verificar qual porta foi criada, entre no gerenciador de dispositivos e procure por UART to
USB bridge:

[[windowsconfserial]]
image::windowsconfserial.png[windowsconfserial,width=339,height=315,align="center",title="O dispositivo de comunicação com a impressora no Windows após a instalação do driver. Pela localização, sabemos que neste caso o driver está na porta &quot;COM4&quot;."]

Se tudo der certo, uma vez que o driver esteja instalado, a autodetecção do Slic3r vai funcionar nas opções,
quando você apertar a setinha que desenrola as portas disponíveis:

[[slic3rseriallinux]]
image::slic3rseriallinux.png[slic3rseriallinux,width=493,height=286,align="center",title="Apertando a setinha para ver as opções, o Slic3r automaticamente lista as portas que achou. No Linux, elas serão `/dev/ttyUSB<número>` ou `/dev/ttyACM<número>`; no Windows, `COM<número>`; no Mac OS X, `/dev/tty.usbserial*` ou `/dev/cu.usbserial*`"]

Selecionada a porta, a configuração "Speed" se torna automaticamente ativa. A grande maioria das impressoras
3D aceita a velocidade de 115200 bps, que é a configuração segura que usaremos. Algumas impressoras 3D aceitam
velocidade maiores como 225000 e 250000 (confirma o manual da sua impressora). Após entrarmos com a velocidade,
clicamos no botão "Test" para ver se a conexão funcionou com sucesso.

[[slic3rserialtest]]
image::slic3rserialtest.png[slic3rserialtest,width=447,height=282,align="center",title="Se esta mensagem não aparecer após o botão &quot;test&quot; ser clicado, verifique sua conexão e se for Windows veja se a instalação do driver aconteceu corretamente. Lembre-se que Windows usa a denominação `COM<número>` para a porta."]

Na aba "Controller" agora já é possível inclusive se conectar à impressora para enviar alguns comandos
básicos. Como é um recurso recente do slic3r, o que se pode fazer por essa interface ainda é pouco -- mas o
importante é que a configuração habilita o comando "Print" da aba __Plater__, possibilitando que imprimamos
a partir da bandeja virtual.

[[slic3rprinthost2]]
image::slic3rprinthost2.png[slic3rprinthost2,width=596,height=350,align="center",title="Conexão da impressora pela USB com a interface de comando (Manual Control) para executar alguns movimento básicos. Imediatamente após conectar o Slic3r já começa a monitorar as temperaturas da mesa e extrusor."]

[[repetierhostprinthost]]
image::repetierhostprinthost.png[repetierhostprinthost,width=616,height=528,align="center",title="A interface de um software controlador de impressão por USB dedicado - o Repetier Host, um software gratuito fechado. Nele os controles e a visualização são bem mais sofisticados, com a informação das temperaturas da impressora 3D de acordo com o tempo no painel da esquerda (a linha vermelha é a temperatura do extrusor subindo para 230°C, a linha azul a da mesa que aumenta mais lentamente. Os controles da direita permitem entrar comandos G-Code individuais, ajustar coordenadas, mover cada um dos eixos, definir velocidade de extrusão e do eixos, ligar e desligar a ventoinha e até mudar a taxa de extrusão."]

O outro ajuste que da impressora 3D que configuramos mas ainda não apareceu é o diâmetro do bico. Basta clicarmos
no item _Extruder 1_ que o encontramos. Nada mais lógico; o bico é parte do hotend que é parte do extrusor,
logo a configuração fica aí.

[[slic3rconfiguracaoextrusoresbico]]
image::slic3rconfiguracaoextrusoresbico.png[slic3rconfiguracaoextrusoresbico,width=623,height=160,align="center"]

Se tivéssemos mais de um extrusor, cada um deles teria um item de configuração para si, e eles poderiam ter
diâmetros de bicos diferentes. O item seguinte, __extruder offset__, só tem sentido para configurações com
vários extrusores e mesmo assim raramente vai ter valores diferentes de zero pois a posição relativa de cada
extrusor já é dada pelo firmware, liberando o fatiador deste ajuste.

Esta aba ainda tem configurações de retração por extrusor, mas trataremos dela mais à frente pois tem maior
relação com outras configurações de fatiamento.

=== O G-Code nosso de cada dia

Sorrateiramente, trouxemos o leitor até a aba de impressoras do Slic3r, porque na verdade a configuração
inicial de uma impressora tem um passo importante que é por vezes negligenciado: o __G-Code inicial e final__. Na
configuração do sabor de G-Code, o fatiador já coloca alguns valores _default_ de acordo com a configuração
nesses campos, mas algumas vezes esses valores não são suficientes.

E o que são esses campos? São códigos em formato de comandos de G-Code que serão sempre enviados em toda
impressão. São muito específicos ao modelo da impressora, contendo certas tarefas que ela espera serem executadas
por impressão, e podem mudar até de iteração de modelo -- por exemplo, a brasileira Sethi3D AiP A3 introduziu
a necessidade de dois comandos relacionados a autonivelamento de mesa que os modelos anteriores não tinham. Confira
no manual da sua impressora e não deixe de colocar os comandos certos nesses campos.

Além de inicialização e finalização, esses campos também permitem colocar certa "personalidade" à sua
impressão. No firmware específico da Sethi3D AiP (Repetier Firmware), o comando de G-Code "M120 S<frequência>
P<repetições>" toca um bipe na frequência determinada com tantas repetições e pode ser usada para uma
musiquinha de fim. Esse comando também ilustra as diferenças entre G-Codes: em outros firmwares, o M120 tem
outro significado e o comando que gera bipes é o M300. É a isso que nos referimos quando falamos em "sabor"
de G-Code. O site _reprap_ é usado como referência agregadora de todas as variações de g-codes usados nos
diferentes firmwares de impressoras 3D: http://reprap.org/wiki/G-code[_http://reprap.org/wiki/G-code_]

Tratamos g-codes em mais detalhes no capítulo "Diversão com G-Code", em que descrevemos o formato e passamos
dicas e truques para ele tornar a sua impressão melhor.

[[exemplogcodeslic3r]]
image::exemplogcodeslic3r.png[exemplogcodeslic3r,width=622,height=639,align="center",title="G-Code para a inicialização de uma impressão da Sethi3D AiP A3. Os comandos são &quot;comentados&quot; para dizer o que fazem após o ponto-e-vírgula. A inicialização faz o &quot;home&quot; dos eixos, isto é, leva cada eixo ao final de curso até sentir o endstop ativar. Com isso, ele sabe a posição da coordenada (0,0,0), nossa origem. Após este comando, ele configura o firmware para usar o sistema métrico (milímetros, e não polegadas) e posicionamento absoluto ao invés de relativo (quando ele receber &quot;X 10&quot;, executará &quot;ir para a coordenada 10 em X&quot;, não &quot;ir para 10 a mais de onde está em X&quot;), executa os dois comandos de autonivelamento de mesa, desliga a ventoinha do bico, levanta um pouco o bico e começa a impressão. No final, ele desliga as temperaturas, leva o extrusor todo à esquerda (X=0), desliga os motores e toca som de término. Outros campos de G-Code configuráveis que não aparecem: G-Code para executar antes de troca de camada; G-Code para executar depois de troca de camada; e G-Code para executar na troca de extrusor. Este último só concerne a configurações com múltiplos extrusores."]

=== Diâmetro e temperatura

Faltam esses ajustes, e basta pensar que eles são específicos em relação ao __carretel de filamento
usado__. Enquanto para aquele seu carretel de PLA vermelho (cuja espessura medida é de 1,69mm) usa 220°C no
extrusor e 60°C na mesa, o seu outro carretel, de ABS azul com diâmetro médio de 1,72mm, você usará 235°C
no extrusor e 120°C na mesa. Você pode ter aquele PLA específico de 1,7mm cujo vendedor recomenda 190°C no
extrusor e mesa a 50°C, ou aquele PETG de 1,65mm em que usa 250°C no extrusor e 80°C na mesa. Esses ajustes
estão na aba de filamento do Slic3r e em outros fatiadores seguem o padrão de ter "perfis" ou "seções"
diferentes para que possa ter muitas dessas combinações armazenadas. Essa configuração pode se tornar bastante
complicada, caso o leitor tenha curiosidade tratamos mais a frente em detalhes.

[[slic3rperfisdefilamento]]
image::slic3rperfisdefilamento.png[slic3rperfisdefilamento,width=607,height=307,align="center"]

=== O Multiplicador de Extrusão

Você sabe o que é o diâmetro e as temperaturas, portanto que _Extrusion Multiplier_ é esse? No Slic3r ele é
um número pelo qual ele modificará o seu cálculo de plástico a ser extrudado. Digamos que para determinada
camada ele calcula que gastará 15 mm^3^ de plástico e você põe o multiplicador de extrusão em 1.1; 15 × 1.1 =
16.5 mm^3^, que é o quanto ele realmente gastará de plástico, causando o que se chama de __superextrusão__. Em
alguns casos, a superextrusão pode ser útil para fazer camadas mais grossas, mais resistentes. O mesmo pode ser
dito da subextrusão, extrudar menos do que deveria (com o multiplicador em 0,9, por exemplo): tem uma utilidade
limitada na fabricação de detalhes mais finos ou rarefeitos.

Como pode isso acontecer? Por que deveríamos poder mudar o ajuste de quanto plástico sai da impressora, se ela
tem todas as medidas necessárias e consegue calcular o volume final?

Para responder a essa pergunta, é preciso entender o mecanismo de extrusão da impressora e as propriedades dos
materiais. A parte do mecanismo já vimos: um "pinhão" dentado crava seus fios no filamento, auxiliado por um
rolamento com mola para fazer pressão. Quando o pinhão rotaciona, esses fios, enterrados no plástico, empurram
o filamento para a câmara de derretimento. No entanto, os materiais mais flexíveis e moles, como o ABS, cedem
muito mais facilmente aos fios do pinhão, tendo eles enterrados profundamente, enquanto que os mais rígidos,
como PLA, oferecerão maior resistência. Esse contato diferenciado entre filamentos faz com que para a mesma
_velocidade angular_ (taxa com que o pinhão roda) se traduza em diferentes __velocidades escalares__.

[[diferencasabsplaextrusao]]
image::diferencasabsplaextrusao.png[diferencasabsplaextrusao,width=642,height=439,align="center",title="**Mesmo ângulo, diferentes deslocamentos** - a diferença entre os contatos do pinhão no filamento fazem com que filamentos mais rígidos extrudem mais que os mais flexíveis, conforme mostra a figura. Para o mesmo ângulo, o ABS se desloca menos que o PLA. A escala foi exagerada para ilustrar o efeito."]

Sempre é interessante ver a história da reprap, e o blogueiro _nophead_ tem um artigo
mais profundo sobre este problema da ‘mordida’ do pinhão que virou referência:
http://hydraraptor.blogspot.com.br/2011/03/spot-on-flow-rate.html[_http://hydraraptor.blogspot.com.br/2011/03/spot-on-flow-rate.html_]

Apesar deste fator, e apesar de o uso de um fator de extrusão para "compensar" esse movimento maior do ABS
(o vloqueiro Maker __Thomas Sanladerer__, em seus testes, recomenda usar um fator de extrusão de 90% / 0,9 para o
PLA com pinhões "MK8" padrão, considerando a impressora tendo sido calibrada com ABS), esta configuração é
abusada no meio da impressão doméstica, pois acaba sendo um "band-aid" que conserta temporariamente vários
problemas (como um filamento emborrachado que esteja escorregando). Em geral, no entanto, tanto superextrusão
quanto subextrusão são efeitos indesejados e que apontam contra a qualidade de uma impressão.

Isso é um pouco mais grave porquanto existam operadores que usam o multiplicador de forma __incorreta__, diferente do
que foi planejado. Vimos que colocamos a medida _real_ do diâmetro do filamento, a que medimos, e não a _nominal_
que seria de 1,75mm (ou de 3mm, caso você use este tipo). A razão disso é que ela entrará em muitas fórmulas
e algoritmos diferentes do fatiador na consideração de quanto plástico deve soltar, que outras compensações
deve fazer, a que velocidades, em que cantos e curvas e retas das formas que plota no espaço. Quanto mais este
valor diferir do real, e os fatiadores têm se tornado mais sofisticados com controles complexos de fluxo, mais
estas fórmulas divergirão, e menos controle do processo se tem. A forma incorreta de preencher estes valores
é a de colocar uma medida que não equivale ao diâmetro real do filamento e tentar "corrigir" esta medida
incorreta usando um multiplicador de extrusão que compense.

Por exemplo, coloca-se 1,75mm na medida do filamento (sem medi-lo) mas ao se tentarem impressões com esta medida,
percebe-se que as peças estão saindo ralas, com subextrusão. Isso acontece porque tal filamento tem a medida real
média de, digamos, 1,65mm. Por tentativa e erro, o operador descobre que se colocar um multiplicador de extrusão
de 1,06, as impressões ficam boas. E nesse ínterim ele perdeu plástico, tempo, e mesmo com o multiplicador
potencialmente não terá peças tão boas quanto se pusesse as medidas corretas (1,65mm e multiplicador de 1,0),
pois o fatiador está "acreditando" que o filamento tem realmente 1,75mm e calculando como devia, inclusive
levando em consideração outros multiplicadores, compensações e controles de fluxo que precisa fazer e só
está _compensando_ no final o seu resultado já processado.

O efeito do multiplicador de extrusão é mascarar defeitos na impressora, que podem ser inclusive com várias
causas distintas. Algum índice errado ou perdido no meio do caminho, alguma largura de camada -- não precisa
nem ser no fatiador, pode ser no firmware (como os passos por mm) ou um problema mecânico.

A lição aqui é: o multiplicador de extrusão é um índice para ser usado com muitas reservas e raramente. Ele
não serve para compensar uma impressora descalibrada ou medidas imprecisas. Use basicamente em "emergências",
quando por algum motivo que ainda não pode determinar, seu extrusor está causando super ou subextrusão e é
necessário corrigir. Note ainda que os _hosts_ de impressão costumam oferecer como recurso um multiplicador de
extrusão interativo, isto é, você o modifica em tempo real enquanto a impressão acontece; muitas das impressoras
3D que têm um painel de LCD também permitem fazer isto por este painel durante a impressão.

Alguns fatiadores -- o Cura, por exemplo -, ao invés de colocar um fator de multiplicação colocam uma
porcentagem. O efeito é o mesmo, é o fator multiplicado por 100. Um multiplicador de extrusão de 1,2 do Slic3r
é correspondente a um multiplicador de extrusão do Cura de 120% (e a nomenclatura no Cura para a configuração
deste item é __flow__, fluxo).

[[coracaoantiextrusao]]
image::coracaoantiextrusao.png[coracaoantiextrusao,width=553,height=390,align="center",title="O uso irresponsável do multiplicador de extrusão é de quebrar o coração, como ilustra esta fotografia de um caso fatal de subextrusão."]

== Os mesmos ajustes de sempre

Se você não se cansou _ainda_ de falarmos destas configurações, prepare-se porque vamos começar tudo de novo. A
razão é que há outros fatiadores, e precisamos dar bons parâmetros de comparação. Mais do que a nomenclatura e
as configurações de um fatiador específico, os conceitos é que são importantes, e são eles que serão fixados
na memória. Se ensinamos apenas um programa, daqui a 5 anos ele pode nem ser mais usado -- como aconteceu com
o fatiador __skeinforge__. Certas impressoras proprietárias têm fatiadores bastante diferentes, mas que usam os
mesmos conceitos. Certas pessoas terão preferência por um software ou outro. A todo dia aparecem novos fatiadores,
existe francamente uma corrida por recursos entre eles atualmente. Não há como ensinar um único software sem
estar fazendo uma aposta que quem paga é o leitor.

O Slic3r foi escolhido para ilustrar este livro porque ele é ao mesmo tempo rico em recursos, organizado
racionalmente e suficientemente genérico que sirva para intuir e ilustrar os ajustes de outros fatiadores.

=== Simplify3D

Este competente fatiador proprietário tem usabilidade boa e variados recursos únicos que mesmo com sua forma de
venda sem _trials_ ou versões limitadas lhe renderam uma boa parcela do mercado. Uma boa qualidade de fatiamento,
colocação manual de suportes que também são facilmente destacáveis fisicamente, um bom painel de controle
pela USB, suporte a variados tipos de arquivos de saída, recursos de sintonia fina e um polimento muito grande de
interface são os pontos fortes deste software, que é uma opção sólida para uso profissional com suporte oficial
e workflow produtivo. É necessário advertir, entretanto, que seu acordo de uso (EULA) proíbe o compartilhamento
dos arquivos produzidos com ele e engenharia reversa dos recursos e formatos do software. Softwares proprietários
inevitavelmente acabam tendo tais limitações por seu frequente apelo à escassez artificial; neste caso,
a proibição do compartilhamento de g-codes foi incluída para evitar que algum licenciado desse um jeito de
fatiar pela nuvem, o que permitiria muitos usuários usufruindo de uma única licença.

Todos os ajustes exibidos aqui são com o Simplify3D com a interface configurada no modo avançado, como fizemos
com o Slic3r.

No Simplify3D, a primeira aba se refere ao extrusor e nela já temos a configuração do diâmetro do bico, seguida
do multiplicador de extrusão. Curiosamente, temos também aí ajustes de retração associados ao extrusor,
algo que trataremos mais à frente.

[[simplify3dbico]]
image::simplify3dbico.png[simplify3dbico,width=631,height=504,align="center",title="O diâmetro do bico nas configurações do Simplify3D"]

Já as configurações de ajuste de temperatura do filamento o Simplify3D organiza numa aba à parte, em que
todos os elementos com temperatura controlável ficam organizados. Assim, você pode ter um elemento extrusor,
um segundo elemento extrusor (para quando tem extrusor duplo), a mesa aquecida e até ter elementos para câmara
aquecida e outras mesas aquecidas (algumas impressoras 3D de maior volume usam isso).

[[simplify3dajustetempextrusor]]
image::simplify3dajustetempextrusor.png[simplify3dajustetempextrusor,width=529,height=450,align="center",title="Ajuste de temperatura do extrusor, com possibilidade de diferentes temperaturas para diferentes camadas (&quot;setpoints&quot;)"]

[[simplify3dajustetempbed]]
image::simplify3dajustetempbed.png[simplify3dajustetempbed,width=531,height=429,align="center",title="Ajuste de temperatura da mesa aquecida"]

Anti-intuitivamente, os ajustes de forma e tamanho de mesa do Simplify3D ficam na aba G-Code, e os G-Codes de início
e fim não ficam nessa aba -- ficam na aba scripts. Veja no entanto que a forma de mesa é um "override" em
cima do __profile__. O Simplify3d tem uma organização diferente do Slic3r, ele tem os "profiles" que definem
categorias maiores (por exemplo, um profile por impressora 3D) e os "processes" que definem configurações
específicas (que é o diálogo que abrimos, e um "process" irá sobrepujar as configurações de mesa do
"profile" se o "Update Machine Definition" estiver ligado). Vemos também a configuração do sabor de
firmware e da velocidade da conexão USB-serial.

As configurações de máquina do Simplify3D permitem alguns ajustes que não vimos até agora: especificar
a direção em que o fim de curso ocorre e na visualização, inverter algum dos eixos. Ele também tem os
"offsets" de extrusor que a configuração do Slic3r oferece e que quase nunca são usados.

[[simplify3dbuildvolumeefirmware]]
image::simplify3dbuildvolumeefirmware.png[simplify3dbuildvolumeefirmware,width=611,height=459,align="center"]

O diâmetro do filamento aparece na categoria "Other" (outros), outra organização não muito intuitiva de
configurações. Apesar de sua ululante excelência técnica, parece ter faltado aos arquitetos do Simplify3D um
pouco de criatividade para nomeação de diálogos. Nesta aba vemos também várias outras configurações que
dizem respeito à qualidade de impressão, que será o tema do capítulo seguinte.

Seguido do diâmetro, dois itens muito úteis aparecem: o *preço* do filamento por quilo e a densidade
do filamento. Estes dois índices dão base ao Simplify3D para que, após fatiar, ele calcule quantos gramas de
filamento você gastará (ele sabe o volume, tudo o que precisa para saber o peso é a densidade), e como ele tem
o peso, pode calcular também o custo financeiro do uso do material. Se o operador cobrar impressões 3D por peso,
pode colocar diretamente seu preço neste campo que quando realizar o fatiamento o Simplify3D já dirá quanto
ele deve cobrar.

[[simplify3dfilamentproperties1]]
image::simplify3dfilamentproperties1.png[simplify3dfilamentproperties1,width=582,height=437,align="center"]

=== Cura

É preciso esclarecer que para fins práticos, é sensato dizer que existem *dois* fatiadores de nome Cura: O que
tem a numeração até a série 15.04 (sendo a versão 15.04.6 a de manutenção mais recente) e o que foi quase
totalmente reescrito, cuja numeração na época da redação deste texto estava em 2.7.

[[doiscurasdiferentes]]
image::doiscurasdiferentes.png[doiscurasdiferentes,width=642,height=235,align="center",title="Dois Curas: o da esquerda, o 15.04; o da direita, 2.3.1, com muito mais recursos e configurações."]

O redesenho do Cura tem seus motivos. Muitos recursos a mais foram adicionados ao fatiador, mas a "poeira"
de tanta mudança ainda está se assentando. Quando um software sofre mudanças tais que perde recursos que antes
tinha, a esses recursos perdidos se nomeiam "regressões". Algumas regressões do 2.7 em relação ao 15.04,
por exemplo, são a importação de objetos no formato .AMF, a opção de configuração para preço do filamento
e a extrusão volumétrica.

Por outro lado, a diferença de recursos (novos) que o Cura novo tem em relação ao 15.04 é tão grande que não
valeria a pena listar aqui. Basta dizer que ele tem tantos recursos e tão granulares que permite que você ajuste
a _visibilidade_ deles.

[[curamuitosajustes]]
image::curamuitosajustes.png[curamuitosajustes,width=542,height=474,align="center",title="Repare no tamanho da barrinha de scroll, ela reflete a quantidade de itens mostrados em relação aos disponíveis."]

Esse é, portanto, um grande diferencial dessa nova versão do Cura. Ele permite sintonia milimétrica de cada
pequeno detalhe do fatiamento, de forma que quem precisa de ajustes finos terá no fatiador, hors concours,
a melhor opção. O outro ponto forte que se ressalta do fatiador são os itens "experimentais", por assim
dizer, que ele tem: um ajuste que permite imprimir em "arame", sem utilizar camadas, a sua forma tridimensional
(impressão em arame/wire printing); um outro ajuste que introduz "ruído" na superfície do objeto, dando
aspecto rugoso ou acidentado (pele felpuda/fuzzy skin); suportes cônicos; malhas de preenchimento; mudança da
geometria do objeto para imprimir sem suportes; e tantos outros que ocuparão um bom tempo dos mais exploradores. O
software ainda se sobressai em realizar o fatiamento rapidamente (e ele ocorre em backgroud, automaticamente),
conseguir impressões de boa qualidade e ainda conseguir fazer a impressão demorar menos que em outros fatiadores.

Em termos de organização, o Cura não tem tantos painés, diálogos, abas como Slic3r e Simplify3D. Ele tem os
ajustes de impressão e impressoras; e permite a você definir "profiles" e "materiais" a partir dos ajustes
de impressão. Vários dos nossos itens iniciais, incluindo até mesmo o G-Code de início e fim de impressão,
estão diretamente no diálogo de configuração de impressora.

[[curaeorganizadoviu]]
image::curaeorganizadoviu.png[curaeorganizadoviu,width=615,height=531,align="center",title="Em termos de organização, o Cura dispõe de forma muito intuitiva as configurações, como dá pra ver na tela de configuração da impressora."]

E os outros itens de nosso interesse -- temperaturas e diâmetro do filamento? Não é preciso procurar muito. Estão
logo no início, nas configurações de ajuste de material, seguidos pelo "flow" que é o multiplicador de
extrusão.

[[curaretracaomaterial]]
image::curaretracaomaterial.png[curaretracaomaterial,width=614,height=563,align="center",title="Uma diferença do Cura é que ele faz uma associação da retração com o material, ao invés do extrusor, como dá para ver na screenshot. Isso é positivo e, de fato, preferível, pois ajustes de retração variam bem mais por filamento (por exemplo, rígido vs. flexível) do que por extrusor."]

== Importação e disposição de peças na mesa

Uma vez tenhamos configurado esse mínimo no fatiador, já podemos -- antes mesmo de qualquer elaboração nas
configurações -- usar o software para montar nossa "mesa de impressão virtual", isto é, o que queremos
que saia na impressora. O caso mínimo seria uma forma tridimensional no tamanho e orientação exata em que foi
modelada, bem no centro da mesa, e nesse caso basta abrirmos a figura e mandarmos imprimir. Para todos os outros
casos, no entanto, devemos aprender como manipular, dispor e até editar as peças na mesa.

Antes, uma explicação: o ato de carregar as peças na mesa é comumente denominado de __importação__. E
é assim chamado justamente porque, em relação aos dados tridimensionais da peça carregada, o fatiador vai
associar uma série de outros dados: escala, orientação, posição, extrusor, filamento, suportes e outros
parâmetros. Alguns fatiadores, como Simplify3D e Cura, permitem salvar a mesa de impressão com todos os metadados
associados a ela, de modo que você poderá abrir depois e recarregar não só as disposições de todas as peças,
como as configurações associadas a elas. No caso do Simplify3D, tal arquivo é o ".factory", aquele mesmo
cuja engenharia reversa é proibida pela EULA do software (o que efetivamente proíbe outros softwares de poderem
importar o formato); no caso do Cura, elas são guardadas em um arquivo de formato aberto ".3mf". Alguns dos
fatiadores, como o Slic3r, permitem também _exportar_ a disposição da mesa como algum formato tridimensional
como STL ou AMF, mas perdendo os metadados de impressão.

Outra opção notável de "importação" é o fatiador carregar uma figura _bidimensional_ convencional como
GIF, JPEG, PNG e empregar um algoritmo para transformá-la em uma forma tridimensional. As melhores figuras para
objetos simples são as iconográficas em preto e branco, mas o software também processa figuras complexas de
muitos tons de forma a criar um "lithopane" ("quadro" com relevo saltado). Se o seu fatiador não suporta
esse tipo de importação, existem softwares gratuitos e livres que fazem essa transformação externamente, como
o multiplataforma __png23d__, que transforma bitmaps "png" em arquivos .STL ou de OpenSCAD. Existem vários
serviços de nuvem que fazem o mesmo, incluindo o próprio thingiverse, e o integrante da lista "reprapbr"
*JP* fez um software proprietário gratuito de lithopanes para Windows, com interface gráfica bem intuitiva:
http://www.imprimindo3d.com.br/software-para-impressao-de-lithophanes/[_http://www.imprimindo3d.com.br/software-para-impressao-de-lithophanes/_]

[[curasimplify3dimportacaopng]]
image::curasimplify3dimportacaopng.png[curasimplify3dimportacaopng,width=642,height=678,align="center",title="A mesma figura PNG de duas cores, ressaltada em vermelho no centro, importada pelo Cura e Simplify3D com os parâmetros para transformá-la em 3D. No Cura basta abrir tais figuras que o diálogo para a transformação (ressaltado em azul) aparece automaticamente. No Simplify3D, o díalogo aparece selecionando o menu &quot;Add-Ins&quot; e &quot;Convert Image to 3D&quot;."]

[[openscadconvertendo2dpra3d]]
image::openscadconvertendo2dpra3d.png[openscadconvertendo2dpra3d,width=623,height=416,align="center",title="O OpenSCAD pode também fazer os lithopanes, caso seu fatiador não tenha essa função. No exemplo, usamos uma fotografia ao invés de um ícone simples pra fazer uma peça em relevos suaves – o mesmo resultado será obtido no Cura ou Simplify3D."]

Uma vez importada a figura tridimensional, ela aparecerá por _default_ no centro da mesa. Se forem importadas várias
figuras, o software pode preguiçosamente dispô-las no centro sobrepondo as anteriores, ou pode rearranjá-las na
mesa. Esse comportamento é configurável (**Slic3r**: File → Preferences → Auto-center parts; **Simplify3D**:
Tools → Options → Models → Automatically center and arrange imported models; **Cura**: Preferences → Configure
Cura... → General → Ensure models are kept apart _e_ Automatically drop models to the build plate) e tanto
Simplify3D quanto Slic3r ainda disponibilizam um botão de arranjo instantâneo caso você tenha "bagunçado"
a mesa.

Se o formato que você importou foi STL e o arquivo tem múltiplos objetos, você pode ter um problema; como dissemos
ao mencionar o formato, ele não tem informações de "objetos separados", então o fatiador considera cada
arquivo STL carregado como um único objeto. Isso pode ser inconveniente para posicionamentos e transformações,
pois ele só permitirá a você operar em todos de uma vez. Para evitar isso, tanto Slic3r quanto Simplify3D
permitem a você separar os vários objetos:

[[slic3rdivisaoobjeto]]
image::slic3rdivisaoobjeto.png[slic3rdivisaoobjeto,width=642,height=373,align="center",title="No Slic3r, você clica em cima do objeto composto a ser dividido (o `varios.stl` que aparece na listagem à direita) e seleciona &quot;Split&quot;. A partir daí cada objeto poderá ser manipulado de forma separada. No Simplify3D, o caminho é menu &quot;Mesh&quot; → &quot;Separate Connected Surfaces&quot;."]

Você vê que no menu do Slic3r ainda aparecem opções para manipulações dos objetos como rotacionar, "scale"
(redimensionar) e espelhar. Mas primeiro vamos ao mais básico: o melhor é primeiro você aumentar o seu campo
de visão, ou seja, _diminuir o zoom_ pra ver mais da tela. Você faz isso usando a rodinha do mouse; movendo pra
frente, a visão se aproxima e pra trás, ela se distancia. Isto funciona do mesmo jeito em todos os fatiadores.

No Slic3r, se você clicar e arrastar o objeto, ele é movido por cima da mesa. Já o Cura apresenta um menu de
manipulações à esquerda, a manipulação inicial é de "translação" (mover na mesa) e se você clicar
e arrastar a peça ela se move como no Slic3r. No Simplify3D é ligeiramente diferente: para mover a peça você
deve estar com a tecla _Ctrl_ apertada, clicar e arrastar. Sem o __Ctrl__, ele não mexe na peça, fazendo apenas a
_rotação_ do ponto de vista. A idéia aqui é evitar que se arraste as peças sem querer. Você pode ainda querer
somente _deslocar_ lateralmente e para cima/para baixo o ponto de vista (movimento que em inglês é referido como
__*pan*__). De uma forma mais organizada:

* **Slic3r**: Botão esquerdo na peça para arrastá-la; botão esquerdo fora das peças para rotacionar o ponto de
vista; botão direito ou do meio para __pan__.
* **Simplify3D**: Ctrl + botão esquerdo na peça para arrastá-la;
botão esquerdo em qualquer lugar para rotacionar o ponto de vista; botão direito para __pan__; o botão do
meio "reseta" a visualização. Esses atalhos podem ser mudados em Options → Preferences → Mouse/Keyboard
shortcuts e em especial se aconselha desmarcar o "[ ] Middle mouse button resets view" se você mexe com os
vários fatiadores, visto que será comum confundir as teclas.
* **Cura**: Com o modo "translação" selecionado,
botão esquerdo na peça para arrastá-la; botão direito em qualquer lugar para rotacionar o ponto de vista;
botão do meio para __pan__.

[[curamodosmanipulacao]]
image::curamodosmanipulacao.png[curamodosmanipulacao,width=642,height=401,align="center",title="Modos de manipulação de objetos do Cura. Quando um deles é selecionado (quadro à direita) aparecem mais opções sobre a manipulação. No caso ilustrado a translação pode ser feita arrastando o objeto na mesa ou entrando manualmente as coordenadas nos campos que aparecem."]

=== Configurações adicionais de posicionamento

Cada fatiador costuma vir com suas próprias facilidades e recursos extras de posicionamento e disposição,
e vale a pena explicitar como funciona em cada um deles.

* **Slic3r**: sendo ainda o mais simples dos três em sua interface, não tem muitos recursos especiais de
posicionamento e mesmo o posicionamento pela interface não é lá muito intuitivo. Também não ajuda o fato de
este fatiador nem mesmo implementar a função básica de **desfazer (undo)**^1^. Temos nas preferências gerais um
ajuste para auto-centralizar peças, na interface da mesa um botão para "arranjar" as peças automaticamente e o
botão direito para uma série de operações, ajustes e configurações por objeto. Um ajuste de posicionamento que
merece menção especial, no entanto, é a de rotação das peças. Como ela é feita somente pela especificação
de um número (os graus de rotação em relação ao eixo), pode ser muito difícil visualizar como tal rotação
acontece.  +
Nesse sentido, é útil resgatar um pouco de teoria da modelagem tridimensional. Os softwares de
tratamento de forma 3D seguem a *regra da mão direita* para rotação.

[[regramaodireita]]
image::regramaodireita.png[regramaodireita,width=642,height=499,align="center",title="A regra da mão direita mostra o sentido de rotação em relação ao eixo. Se o desejado for rotacionar no sentido inverso, basta usar um valor negativo (ex.: 90°)."]

[[regramaodireitanoslic3r]]
image::regramaodireitanoslic3r.png[regramaodireitanoslic3r,width=642,height=319,align="center",title="Aplicação da regra da mão direita para um objeto no Slic3r. Escolhemos o eixo X, indicado em vermelho, e pedimos pra rotacionar 90° positivo. Os quatro dedos apontariam para a rotação no sentido destacado."]

O Cura faz as rotações
com o mesmo referencial (pois ele permite entrar valores), mas o Simplify3D pode confundir quem não quiser usar o
modo interativo e colocar os valores diretamente, pois a representação _default_ dos eixos dele inverte o Y pois
assim a visualização da impressão em impressoras 3D cartesianas fica mais fácil. Para a rotação funcionar
segundo a regra da mão direita, é preciso desmarcar a inversão do Y, ou simplesmente decorar que os sentidos
de rotação numérica, no default dele, são invertidos.

[[simplify3dnaomaodireita]]
image::simplify3dnaomaodireita.png[simplify3dnaomaodireita,width=507,height=364,align="center",title="O Simplify3D não obedece à regra da mão direita por causa desta configuração default. Pode-se desmarcá-la ou memorizar o Simplify3D como tendo &quot;regra da mão esquerda&quot;."]

* **Simplify3D**: As configurações de visualização, posicionamento e disposição estão espalhadas pelo menu
*Tools* → *Options* do fatiador:
+
[[simplify3dtoolsoptions]]
image::simplify3dtoolsoptions.png[simplify3dtoolsoptions,width=463,height=605,align="center"]
+
As importantes para nosso caso serão:
+
** *Swap mouse scroll wheel zoom direction* -- faz com que o sentido da rodinha do mouse
se inverta: para trás diminuirá e para frente aumentará o zoom.
** **Middle mouse button resets view**: caso
o ângulo de visualização esteja muito ruim, você pode resetá-lo para o _default_ simplesmente pressionando o
botão do meio do mouse. Se você usa vários fatiadores ou programas de modelagem, é recomendado desligar esta
configuração pois muitos deles usam o botão do meio para outras funções, levando a pressioná-lo sem querer
no fatiador e perdendo a visualização em que estava.
** **Always show full 3D transform gizmo**: para fazer
as transformações visualmente o Simplify3D apresenta "gizmos" (controles) em que se clica com o mouse para
realizá-las. Com essa configuração selecionada, o fatiador sempre mostrará os 3 eixos para transformação ao
invés de somente um.
+
[[simplify3dgizmos]]
image::simplify3dgizmos.png[simplify3dgizmos,width=642,height=263,align="center",title="Controle de rotação sem &quot;full gizmo&quot; (na figura com a rotação para o eixo Z) e com &quot;full gizmo&quot; (todos os eixos) no Simplify3D."]
+
** Na aba *Machine* temos novamente de interesse a possibilidade de ligar ou desligar na configuração default o
"flip Y" visto na regra da mão direita.
** Na aba *Models* temos o "**Automatically scale to correct unit system without prompting**". Como vimos, o formato STL não inclui unidades, embora seja assumido o milímetro. Quando
o Simplify3D importa um objeto e ele é pequeno demais, ele assume que foi gravado em _polegadas_ (inches), que
são maiores. Normalmente ele mostra uma janela de diálogo ao importar tais peças, mas com essa configuração
ligada ele transforma a figura automaticamente para polegadas (uma polegada é igual a 25,4 milímetros, ou seja,
ele aumenta a figura em 2540%).
** Ainda na aba *Models* há a opção para ele dispôr as peças automaticamente
conforme os modelos são importados, **Automatically center and arrange imported models**. Como ele já possui
o botão *Center and Arrange* na interface principal, desligar essa configuração pode ser útil quando se quer
"fundir" peças ou posicioná-las livremente.
** Interativamente, o Simplify3D tem dois ótimos atalhos para
manipular posição e rotação; são eles o *Ctrl-T* (drop / largar peça) e *Ctrl-L* (align / alinhar com a mesa).
*** O *Ctrl-T* analisa a peça e vê onde é a posição mais baixa dela no eixo Z, e alinha essa posição para ter Z=0
(ou seja, encosta na mesa). Na prática esse modificador serve para "largar" peças de modo que encostem na mesa
(não fiquem flutuando) ou, se a peça estiver com partes __para baixo da mesa__, colocá-la acima.
*** O *Ctrl-L* é uma função mais útil: uma vez apertada a combinação de teclas, permite ao usuário selecionar uma _face_
da peça. Quando clicada com o botão do mouse, o fatiador rotaciona a peça de modo com que essa face se alinhe
com a mesa, e aí realiza a função de "largar" a peça nessa rotação de modo que encoste na mesa. Veja
que se a face selecionada não for a mais baixa na peça, ela não encostará na mesa, apenas ficará alinhada. +
Tanto no Ctrl-T quanto no Ctrl-L as modificações de posicionamento e rotação ficam armazenadas nos campos
numéricos do objeto, e podem ser zeradas restaurando o objeto a coordenadas "default".
+
[[simplify3dcontroll]]
image::simplify3dcontroll.png[simplify3dcontroll,width=642,height=366,align="center",title="O modificador Ctrl-L no Simplify3D. A face selecionada, à esquerda, está ressaltada em vermelho brilhante. Ao se clicar nela a peça é rotacionada e largada na plataforma, mas a face selecionada não necessariamente estará encostada nela, apenas alinhada. No resultado, à direita, a face alinhada (não visível) tem sua distância mostrada em vermelho escuro e o ponto de contato da peça com a mesa é ressaltado em verde claro."]

* **Cura**: as opções gerais do Cura, que afetam visualização e posicionamento, podem ser um pouco difíceis
de compreender. A tela de configuração pode ser acessada no Menu __Preferences → Configure Cura → General__:
+
[[curapreferencesgeneral1]]
image::curapreferencesgeneral1.png[curapreferencesgeneral1,width=642,height=530,align="center",title="Tela de configuração geral do Cura 2.4"]
+
As opções pertinentes são:
+
** **Viewport Behaviour -- Display overhang**: na visualização default, com essa opção ligada mostra em
vermelho brilhante os overhangs/seções pendentes da forma.
** **Center camera when item is selected**: desliza
a visualização da câmara para focalizar em um objeto quando se o seleciona (sem mudar o nível de __zoom__).
** **Ensure models are kept apart**: já mencionada, com ela ligada os modelos são espaçados de forma a não
colidirem ou se penetrarem.
** **Automatically drop models to the build plate**: automaticamente deixa os objetos
importados ao nível da mesa (sem rotacioná-los).
** As três opções seguintes são relacionadas e merecem uma
explicação: sendo uma aplicação __OpenGL__, isto é, que se vale de aceleração de hardware para desenhar as
formas tridimensionais na tela, o Cura em sua inicialização tenta ativar a renderização, mas se não consegue
(o que pode acontecer por a máquina não ter hardware para isso ou não ter o driver instalado), cai em __modo
de compatibilidade__, bem mais lento. Nesse modo de compatbilidade, as opções servem para não sobrecarregar
o processador. Veja que elas só valem para a __visualização de fatiamento__, não para a visualização 3D
default. A *Only display top layer(s) in layer view compatibility mode* faz com que nessa visão _só_ seja mostrada
a camada superior ou camadas superiores do intervalo, e a *Display five top layers in layer view compatibility mode*
diz que o número dessas camadas superiores mostradas é cinco. A opção *Force layer view compatibility mode
(restart required)* força que o Cura já inicie em modo de compatibilidade sem tentar ativar a aceleração de
hardware, e só começa a valer quando a aplicação é reiniciada.
** **Scale large models**: com essa opção
ativada, verifica se a peça cabe no volume de impressão configurado, e se não couber a reduz até que caiba.
** **Scale extremely small models**: como no simplify3d, se detecta se a peça é pequena demais (mais de 100 vezes
menor que o volume de impressão) e calcula um multiplicador de potência 10 para ela que a coloque em um tamanho
mínimo dentro deste volume.
** **Rotação, posicionamento e modificação interativa**: como mostrado na figura 135, o Cura dispõe de várias
opções para posicionamento, rotação, modificação, etc., e para cada uma delas um controle (gizmo) diferente. Por
__default__, os controles têm uma "grade" de valores em que ficam, mas se você deixar a tecla *Shift*
apertada pode fazer ajuste fino. O mesmo efeito pode ser dado desselecionando o "snap" do controle específico.

image::image315.png[image,width=577,height=432]

** **Rotacionar a peça na mesa para obter orientação ótima**: esta opção do Cura aparece
em _Extensions → OrientationPlugin → Calculate optimal printing orientation_ caso o
_OrientationPlugin_ esteja habilitado nas preferências. O que este plugin faz é analisar a
geometria da peça de forma e rotacioná-la de forma a maximizar o espaço de contato com a mesa
e diminuir o suporte necessário. Uma explicação do algoritmo pode ser lida (em inglês) em
http://www.salzburgresearch.at/blog/3d-print-positioning/[_http://www.salzburgresearch.at/blog/3d-print-positioning/_].

[NOTE]
.Notas:
====
. O Slic3r é software livre e open-source, e qualquer um com conhecimento de
programação pode ajudar a resolver estes problemas. No momento da redação deste
livro, o relato de bug aberto para a implementação do recurso de desfazer em
https://github.com/alexrj/Slic3r/issues/3265[_https://github.com/alexrj/Slic3r/issues/3265_] acaba de ser fechado. É possível que ao ler este parágrafo, o recurso já esteja na versão estável do software e o leitor já possa usá-lo.
====

=== Corte / divisão de peças

Exclusividade do Slic3r, essa função não existe nos outros fatiadores e serve para dividi-la em duas metades
usando de um plano de corte. Para ativá-la, você pode selecionar o objeto e apertar o botão de menu "Cut",
ou clicar com o botão direito e selecionar a opção "Cut".

[[slic3rpartcut1]]
image::slic3rpartcut1.png[slic3rpartcut1,width=642,height=818,align="center",title="Corte de peças do Slic3r. Se escolhe um eixo (na figura, o Z) e a altura do plano de corte é ajustada mexendo na régua ou entrando o valor. As opções permitem Manter (&quot;keep&quot;) a parte superior (upper part), a parte inferior (lower part) ou as duas. A &quot;Rotate lower part afterwards&quot; gira a parte de baixo em 180° para nivelar na mesa, já que se supõe que o plano de corte criará uma superfície plana nesta."]

image::image317.png[image,width=642,height=441,align="center",title="A opção de corte &quot;cut by grid&quot; pedirá dois valores numéricos, que são as arestas dos vários retângulos em que a peça será dividida na mesa. Na figura ilustrada, colocamos 20 x 20 mm, o que daria 100 peças se a mesa de 200x200 estivesse toda preenchida, e no nosso caso resultou em 25 peças."]

.Simulando o corte no Cura e Simplify3D

Apesar de esses fatiadores não terem uma função de corte específica como o Slic3r, é possível usar um editor
de objetos tridimensionais externos como Blender, Meshlab e Meshixer para cortar a peça. Mas também é possível
"simular" esta função se aproveitando do fato que os fatiadores ignoram as partes da peça com coordenadas
menores que zero (abaixo da plataforma virtual de impressão). A desvantagem principal desta abordagem é perder
a flexibilidade de orientar a peça como desejar (já que ela vai ter necessariamente que estar horizontal em
relação ao "plano de corte") e também de ter que saber a dimensão e posicionamento exatos para fazer tal
corte. Demonstraremos no *Cura* pois é trivial saber como fazer as mesmas transformações no Simplify3D, dado
o que já ensinamos.

[[curacutpart1]]
image::curacutpart1.png[curacutpart1,width=578,height=377,align="center",title="**Passo 1**. Carregue a peça e veja suas dimensões, dadas pelo fatiador. No nosso caso pretendemos cortar pelo plano XY, então vamos anotar a altura da peça em Z, **32,5415**."]

[[curacutpart2]]
image::curacutpart2.png[curacutpart2,width=579,height=422,align="center",title="**Passo 2**: Afunde a peça na mesa, colocando um valor negativo em Z. Veja que no Cura para isso funcionar você precisa ter desligado o "Automatically drop models" nas preferências. Anote o valor de Z que escolheu."]

[[curacutpart3]]
image::curacutpart3.png[curacutpart3,width=623,height=379,align="center",title="**Passo 3**: Duplique a peça ou a importe novamente. Rotacione em 180° em X. Lembre-se dos dois valores anotados: 32,5415 e 20,6. Subtraia um do outro e coloque um Z negativo com esse valor, 11,4915."]

[[curacutpart4]]
image::curacutpart4.png[curacutpart4,width=613,height=346,align="center",title="**Pronto**. A peça está dividida e será impressa em duas metades."]

=== Impressão contínua vs. sequencial

Um recurso que todos os fatiadores oferecem, mas de formas diferentes, é a possibilidade de o usuário escolher
como quer que as peças da mesa sejam impressas, quando há várias: todas ao mesmo tempo (a primeira camada de
todas elas, então a segunda camada de todas, etc...) ou uma de cada vez. O primeiro modo é chamado de _impressão
contínua_ e o segundo caso de __impressão sequencial__.

Se a idéia é simples, por que os fatiadores a tratam de forma diferente? Ora, temos que nos lembrar que fatiadores
são softwares genéricos pra tratar uma gama enorme de modelos e tipos de impressoras 3D, e a construção delas
varia bastante, afetando muito o modo como podem tratar a impressão sequencial. Uma Graber i3, com seu carro X
ocupando espaço poucos centímetros acima da altura do bico, não tem a capacidade de fazer várias peças altas
ao mesmo tempo, pois voltaria à coordenada vertical zero e acabaria batendo o carro nas peças já impressas. Já
uma delta tem apenas o volume bem mais vertical do _effector_ e dos braços, podendo imprimir livremente peças
altas em sequência sem colidir com nada. Uma CoreXY, por outro lado, vai ser ainda mais limitada pois tem dois
carros horizontais e as únicas peças que conseguiria imprimir são aquelas de no máximo a altura dos eixos.

E mesmo essas limitações não são absolutas. Numa Graber i3 você pode imprimir as várias peças em fila indiana
no eixo Y e nesse caso seria possível a impressão sem colisão. Mas determinar essa solução pra casos gerais
é virtualmente impossível, pois existem muitas formas de construção e sistemas de eixos de impressoras 3D,
e provavelmente muitos outros a serem inventados. Portanto, você não informa detalhadamente ao seu fatiador o
sistema de eixos que usa e suas limitações específicas, você informa dados mais simples. E aí temos a diferença:
cada fatiador pede dados ligeiramente diferentes para saber se a impressão atual baterá nessas limitações.

[[impressaokapow]]
image::impressaokapow.png[impressaokapow,width=621,height=450,align="center",title="KAPOW! Dependendo da geometria da sua impressora 3D, pode ser mais ou menos limitante imprimir peças em sequência."]

O modo default dos fatiadores é o contínuo. Como os diferentes fatiadores tratam o problema:

* **Slic3r**: A seção _Output options_ (opções de saída) dos _Print Settings_ é onde se trata o modo sequencial. Para
ativá-lo, ligue o "Complete individual objects". Para saber como tratar colisões, o Slic3r trata o problema de
maneira bem simples: exige o "raio" do extrusor e a altura em relação ao extrusor em que o sistema de eixos
está. Se houver mais de um extrusor e o deslocamento estiver configurado no Slic3r ele usará esses ajustes,
mas como geralmente o deslocamento está no firmware, o que se usa nesses casos é somar a distância entre os
extrusores e os raios deles para o controle de colisão.
+
[[slic3rsequentialprinting1]]
image::slic3rsequentialprinting1.png[slic3rsequentialprinting1,width=529,height=212,align="center"]
+
[[slic3rsequentialprinting2]]
image::slic3rsequentialprinting2.png[slic3rsequentialprinting2,width=601,height=396,align="center",title="Como o Slic3r trata as colisões: a altura h (de &quot;height&quot;) e o raio R são entrados. Qualquer peça com partes acima da altura &quot;h&quot; (linha pontilhada) não será possível imprimir."]
+
O Slic3r usa esses dados para avisar sobre colisões já enquanto se arrumam os objetos na mesa. Deixá-los próximos
demais de tal modo que o cilindro colida com algum objeto fará a barra de status mostrar o aviso "Some objects
are too close; your extruder will collide with them" ("Alguns objetos estão muito próximos; seu extrusor
colidirá com eles"). Se os objetos estiverem separados, mas ainda forem maiores que a altura _h_ dos eixos,
ele avisará "Some objects are too tall and cannot be printer without extruder collisions" ("Alguns objetos
são altos demais e não podem ser impressos sem colisões do extrusor".

[[slic3rerrosequentialprinting]]
image::slic3rerrosequentialprinting.png[slic3rerrosequentialprinting,width=578,height=461,align="center",title="Mensagem de erro do Slic3r avisando que as peças são altas demais para serem impressas sequencialmente."]

* **Cura**: como o Slic3r, tem a *altura dos eixos* configurável nas definições de impressora: Preferences →
Printers → Machine Settings → Gantry height. No entanto ele não tem a opção de "raio" ou volume do
extrusor/hotend porque na verdade esses dados estão precisamente especificados internamente para cada modelo de
impressora; ao invés de ser somente um círculo, o arquivo __json__^1^ que define características mecânicas da
impressora 3D permite especificar um polígono com várias arestas. No entanto, como editar esses arquivos-texto
exige conhecimento avançado e muita consulta, na prática esse dado está indisponível para o usuário comum. Por
outro lado, ele tem os dados simplificados "printhead settings" que permitem dizer o mesmo, sendo apenas
distâncias horizontais do bico aos extremos do extrusor.

[[curasequentialmachinesettings]]
image::curasequentialmachinesettings.png[curasequentialmachinesettings,width=642,height=508,align="center"]

[[curasequentialprinting]]
image::curasequentialprinting.png[curasequentialprinting,width=642,height=294,align="center"]

Se você tem uma impressora corretamente cadastrada entre as impressoras do Cura, o dado da forma do extrusor já
estará configurado como devia. Se estiver usando um perfil genérico, para o extrusor sem ventoinha ele usa as
medidas de um quadrado de 2mm de lado, e com ventoinha um retângulo de 30mm no eixo X e 20mm no eixo Y. A altura do
eixo (gantry height) está em 20mm também, e se quiséssemos que o Cura não a levasse em consideração bastaria
colocar um valor bem alto, como 99999999.

[[curasequentialerror]]
image::curasequentialerror.png[curasequentialerror,width=619,height=468,align="center",title="Cura se recusando a fatiar com a altura do eixo configurada como 20mm. Ele mostra as peças &quot;impossíveis de imprimir&quot; com listras e o &quot;volume efetivo de impressão&quot; no modo sequencial (&quot;One at a time&quot;) por linhas azuis-claras."]

* **Simplify3D**: O Simplify3D começa com a abordagem de simplesmente _não ter_ o raio, medida ou formato do extrusor,
tendo especificável (mas não configurável) somente a altura de colisão do eixo. Dessa forma, ele deixa a tarefa
de espaçar corretamente as formas na mesa inteiramente para o operador. O modo sequencial é dado na hora em que
o Simplify3D vai executar o fatiamento, e nesse momento você deve especificar a altura dos eixos.

[[sequentialsimplify3d]]
image::sequentialsimplify3d.png[sequentialsimplify3d,width=598,height=379,align="center",title="O fatiamento sequencial no Simplify3D, com um processo diferente selecionado para cada objeto (a sequência é entre processos e não objetos). A altura dos eixos é dada em 20mm no exemplo."]

E mais uma diferença do Simplify3D é que a sequência não é dada entre cada _peça_ na mesa e sim entre
cada __processo__. Isto significa que se você tem 30 peças, se quiser imprimi-las em sequência precisará de
30 processos, um para cada uma, mesmo que sejam processos idênticos.^2^ +
Mas a melhor diferença ficou para o
final: o Simplify3D não se nega a fatiar se a altura do objeto ultrapassar a altura dos eixos. Ao invés disso,
ele divide em seções: como a altura máxima que ele consegue obter é, digamos, os 20mm que especificamos,
ele imprime os processos em sequência até chegar a 20mm em cada um deles; então, na altura 20mm + uma camada,
ele reinicia a sequência até completar 40mm; e daí em diante, até completar todos os objetos.^3^

[[sequentialsimplify3d2]]
image::sequentialsimplify3d2.png[sequentialsimplify3d2,width=591,height=449,align="center",title="Um recurso valioso do Simplify3D: se as peças forem mais altas que o eixo, ele faz a sequência até chegar a altura máxima, para então recomeçar desta altura. As linhas vermelhas representam movimento de &quot;travel&quot; e o vaivém de uma peça a outra é economizado, tornando a impressão sequencial bem mais rápida. Na figura, vemos apenas duas linhas de travel entre as peças, ao invés de uma para cada camada."]

Neste caso a vantagem do Simplify3D sobre Cura e Slic3r é aparente, mesmo não tendo a análise mais completa
levando em conta o formato do hotend ou extrusor. Resta esperar que tais recursos sejam também implementados
nesses fatiadores!^4^

[NOTE]
.Notas:
====
. Ainda assim, é possível editá-lo com um editor de textos comum. Ele se situa em
__cura/resources/definitions__, tem o nome terminado em _.def.json_ e a lista de variáveis com explicação pode
ser encontrada em https://github.com/Ultimaker/Cura/issues/798[_https://github.com/Ultimaker/Cura/issues/798_]. O
formato do extrusor é dado pelas variáveis _machine_head_polygon_ e __machine_head_with_fans_polygon__.
. Ainda assim, você pode tentar pressionar os desenvolvedores do
Simplify3D para que implementem impressão sequencial em processo único:
https://forum.simplify3d.com/viewtopic.php?f=23&t=1763[_https://forum.simplify3d.com/viewtopic.php?f=23&t=1763_].
. Referência em
https://www.simplify3d.com/support/articles/multi-part-printing/[_https://www.simplify3d.com/support/articles/multi-part-printing/_]
. Por conveniência, o autor abriu relatos de bugs tanto para Slic3r quanto para Cura pedindo este recurso
neles, a seguir: https://github.com/alexrj/Slic3r/issues/3739[_https://github.com/alexrj/Slic3r/issues/3739_]
e https://github.com/Ultimaker/Cura/issues/1493[_https://github.com/Ultimaker/Cura/issues/1493_].
====

== Outra camada de configurações...

...ou configurações de camada? Pois agora que terminamos a __base__, o mínimo que uma impressora precisa para
começar a funcionar, precisamos saber como fazer uma impressão viável (isto é, que chegue à peça final sem
problemas no meio do caminho) e de qualidade (qualquer que seja o fator de qualidade que adotemos: resistência
a tração, a compressão, superfície suave, detalhes finos, aparência esteticamente agradável, etc.).

E se queremos detalhes, precisamos evitar ao máximo o efeito "degrau" que pode acontecer com camadas de
impressão muito grossas, análogo à pixelização que se vê em gráficos de computadores antigos. A _altura de
camada_ (__layer height__, em inglês) é, na prática, a "resolução" da impressora 3D.

[[simplify3dyodabudas0301]]
image::simplify3dyodabudas0301.png[simplify3dyodabudas0301,width=528,height=423,align="center",title="A previsão da trajetória de impressão no Simplify3D de um &quot;yodabuda&quot; em duas resoluções diferentes: 0,1mm de altura de camada (esquerda) e 0,3mm (direita). Percebe-se claramente a perda de detalhes do segundo caso."]

A altura de camada será limitada fisicamente pelo diâmetro do bico, já que é ele que determina a altura máxima
que o filete de plástico consegue atingir. Via de regra, não é recomendável usar uma altura de camada maior que
80% do diâmetro do bico, pois o que acabará acontecendo é que o fatiador vai superextrudar para tentar atingir tal
altura e o que sairá sera um filete embolado, não mais alto. Também não é muito recomendável usar uma altura
de menos de 20% pois o plástico terá uma subextrusão tão acentuada que acabará picotado, enroscando no bico ou
ainda com outros problemas. Portanto, para um bico padrão de 0,4mm se recomenda uma altura de camada entre 0,08mm
e 0,32mm -- tendo sempre em vista que essa "regra" é apenas uma orientação, com muitos casos em que não vale.

[[variosyodabudasabs0301]]
image::variosyodabudasabs0301.png[variosyodabudasabs0301,width=642,height=573,align="center",title="Algumas impressões com filamentos de ABS com 0,3mm e 0,1mm de altura de camada. Apesar de a impressão de 0,1mm ser mais definida, ela também gera mais artefatos. No caso do filamento cinza, os artefatos foram tantos que o filamento foi considerado inviável para impressão fina (é um filamento de testes a que o autor teve acesso). Opções de qualidade do fatiador podem minimizar tais defeitos, mas nada supera o uso de um filamento melhor. Foto do autor."]

Uma camada mais fina torna em geral a superfície mais suave e portanto pode parecer sempre desejável, mas tem
desvantagens. Como o extrusor se movimenta na mesma velocidade quer esteja fazendo uma camada de 0,3mm, quer uma de
0,1mm, e como as peças com camadas de 0,1mm terão três vezes mais camadas, a impressão demorará 3 vezes mais
tempo com a camada de 0,1mm. Como uma impressão 3D já é algo que pode levar horas pra concluir, multiplicar este
tempo por 3 nem sempre é factível. Existem alguns "macetes" que permitem diminuir este tempo, como fazer as
paredes de 0,1mm e o preenchimento interno de 0,3mm, algo que falaremos mais à frente.

Outro problema é que temos maior laminação com mais camadas, e já vimos que a baixa aderência entre camadas é
um fator que atenta contra a resistência da peça. Quanto mais camadas, mais espaço intersticial, e menos robusta
a peça será. Outras propriedades podem pesar contra camadas finas: quando se usam filamentos transparentes,
o grau de refração é maior com camadas menores, então pode ser desejável usar camadas grandes para obter
maior grau de transparência.

Os motores, fusos e pinhões do mecanismo que movimenta o eixo Z de sua impressora terão impacto na qualidade
de camada. Um descompasso entre rotações completas da barra roscada ou fuso com a altura de deposição do
plástico pode trazer deslocamentos micrométricos mas relevantes, e a empresa Prusa Research disponibiliza via web
um mecanismo de cálculo de vários índices para sua impressora 3D, entre eles a de "altura de camada ideal"
considerando o mecanismo.

[[calculadoraprusacamadaotima]]
image::calculadoraprusacamadaotima.png[calculadoraprusacamadaotima,width=596,height=631,align="center",title="A calculadora Prusa para camada ótima. O usuários entra os dados físicos de sua impressora - neste caso, bem comuns: motor de 1,8° de rotação, barra roscada M5 de 0,8mm de espaçamento, sem redução no motor - e diz qual altura de camada gostaria de usar: neste caso, 0,15mm. A calculadora prusa informa que a camada de 0,15mm não seria ideal (em vermelho), pois teria um erro estimado de 1,3mm em 10cm, mas as camadas de 0,148 mm e 0,152 mm funcionariam bem. Pode-se ainda ver que a distância de um &quot;passo&quot; do motor em Z é muito pequena (0,004mm) e com os drivers modernos pode ainda ser dividida em até 32 partes. Isso mostra que a resolução possível de nossa altura de camada é muito alta e poderíamos ter camadas micrométricas se não fosse o altíssimo tempo necessário e a alta chance de a subextrusão não funcionar."]

=== Controle de altura de camada e fatiamento adaptativo

[[FEITO adaptive_slicing]]Por bastante tempo, o Slic3r tem tido um recurso que é tanto bastante útil como pouco
usado, que é o ajuste fino de controle de camadas por altura. Embora outros fatiadores também permitam isso de
várias formas -- como o Simplify3D com seus "processos" --, o que chama atenção no recurso é a rapidez e
facilidade com que isso é feito: selecionando o objeto, clicando com o botão direito e selecionando "settings"
para configurações _por objeto_ e usando a aba "layers" pra definir os intervalos de altura e as alturas de
camada que terão (valores fora desses intervalos terão a altura de camada da configuração geral).

[[slic3rconfiguracaoalturascamadas]]
image::slic3rconfiguracaoalturascamadas.png[slic3rconfiguracaoalturascamadas,width=549,height=460,align="center",title="Configuração fácil de alturas de camada no Slic3r."]

O _fork_ do Slic3r da Prusa Research, o Prusa Slic3r, levou este conceito mais adiante e permite uma configuração
suave e visual das alturas de camada:

[[prusaslic3ralturacamada]]
image::prusaslic3ralturacamada.png[prusaslic3ralturacamada,width=521,height=455,align="center",title="Prusa Slic3r: controle visual de altura de camada. Clicar em diversos pontos do retângulo da curva de alturas de camada à direita ajusta a região para a altura de camada desejada. O fatiador grava a meta-informação dessas alturas de camadas se a mesa for gravada em formato AMF."]

E como se usa esta facilidade? Ora, se você já enxergou uma peça impressa e o efeito de "escada" ou
"serrilhado" na vertical especialmente nas partes que deveriam ser curvas suaves, sabe o problema de se dividir
uma forma em fatias. Quanto menor a espessura dessa fatia, mais suave fica a forma, mas também mais tempo se leva
para imprimi-la. E muitas formas têm seções com linhas mais retas e verticais que realmente não se beneficiariam
das camadas mais finas como as outras, mais suaves e curvilíneas. Não seria portanto ideal que somente as camadas
necessárias fossem mais finas, numa graduação de acordo com sua suavidade ou inclinação?

É mais ou menos isso que se tenta obter, geralmente, quando se editam as alturas de camada em intervalos tanto
no Slic3r quanto o Prusa Slic3r. No entanto, inclinações e suavidades de curva são propriedades geométricas
que podem facilmente ser analisadas, e o procedimento pode perfeitamente ser automatizado. Essa é a idéia já bem
antiga de __fatiamento adaptativo__, mas que recentemente tomou renovado interesse com o algoritmo __VariSlice__™ da
Autodesk^1^, criado pelo time de desenvolvimento da impressora 3D DLP open-source Ember. O algoritmo foi implementado
na linguagem Processing (Java) e seu código-fonte disponibilizado sob licença open-source, podendo gerar tabelas de
alturas para camadas para serem importadas no Slic3r. O time de desenvolvimento da Ember também está participando
da implementação independente da idéia feita pelo usuário __platsch__no Slic3r, com uma combinação das idéias
de manual e automático: o algoritmo inicialmente faz a análise e ajustes das alturas de camadas automaticamente,
com o usuário podendo alterá-las.

[[slic3rprintsettingsminmax]]
image::slic3rprintsettingsminmax.png[slic3rprintsettingsminmax,width=957,height=438,align="center",title="O recurso (recentemente integrado) de fatiamento adaptativo do Slic3r, com configurações associadas de extrusor de altura máxima e mínima permitidas e a __tooltip__ explicando o valor máximo."]

[[slic3rfatiadoadaptativo]]
image::slic3rfatiadoadaptativo.png[slic3rfatiadoadaptativo,width=1229,height=715,align="center",title="A curva de tamanho de camadas à direita da janela menor é modificável de modo bem parecido com o ajuste do Prusa Slic3r (que tem em comum também os mesmos ajustes de máximo e mínimo)."]

.Valor da cúspide

Se a configuração de altura de camada mínima e máxima é fácil de entender, nem tudo é simples no fatiamento
adaptativo. Um valor mais complexo que também pode ser entrado é o _cusp value_ (valor da cúspide). Cúspide
é a ponta ou extremidade aguda de algo, e neste termo ele se refere ao encontro entre as camadas -- o ponto
mais distante da curva da forma. A distância máxima deste ponto em relação à curva é o valor da cúspide^2^,
configurável para o fatiamento. Um valor de cúspide igual a zero fará com que as camadas nunca se desviem da
média das curvas, e as deixará sempre no valor mínimo. Um valor de cúspide igual ou maior que a altura de
camada máxima deixará as camadas sempre no valor máximo.

[[diagramacuspide]]
image::diagramacuspide.png[diagramacuspide,width=535,height=241,align="center",title="O valor da cúspide é igual ao módulo (comprimento) do vetor ilustrado em vermelho, com a base na interseção entre as camadas. "]

Durante o desenvolvimento desse recurso no Slic3r, o valor da cúspide era colocado diretamente, mas se percebeu que os usuários que testam tinham dificuldade de entendê-lo. Por isso, o valor foi trocado para uma _porcentagem_ que se considera mais intuitiva: 0% é correspondente ao valor máximo da cúspide (igual à altura de camada máxima, ou seja, impressão rápida mas grosseira), 100% é correspondente ao valor mínimo (impressão lenta, mas com as camadas igual ao valor mínimo). Entendendo a porcentagem como um equilíbrio entre _tempo_ e __qualidade__, quanto mais alta essa porcentagem, maior a qualidade e menor o tempo. O valor __default__ com que o slic3r vem para ela é **75%**, que é imo para a maioria dos casos.

[[slic3radapqualityhorizontal]]
image::slic3radapqualityhorizontal.png[slic3radapqualityhorizontal,width=741,height=257,align="center",title="Como ligar o fatiamento adaptativo (não se esqueça de definir o mínimo e máximo na aba `printer settings`). O ajuste `Match horizontal surfaces` tenta aumentar ou diminuir as alturas de camada perto de superfícies horizontais para que elas tenham exatamente a altura do modelo."]

[[slic3radaptslicingqualities]]
image::slic3radaptslicingqualities.png[slic3radaptslicingqualities,width=1530,height=712,align="center",title="Diferentes ajustes de qualidade e seus efeitos nas alturas de camada em cada camada (utilizado o 3DBenchy da primeira ilustração)"]

=== Fatiamento adaptativo em outros fatiadores

O Slic3r não é o único fatiador a ter fatiamento adaptativo, mas parece ser o que a implementa de forma mais
consistente, configurável e modificável. Outros fatiadores que a implementam com parâmetros mais automáticos
são o open-source _repsnapper_ e o proprietário __voxelizer__. No caso do repsnapper é apenas uma opção a
ser ligada ou desligada e no caso do voxelier só o tamanho de camada mínimo e máximo são configuráveis.

[[fatadaptativonorepsnapper]]
image::fatadaptativonorepsnapper.png[fatadaptativonorepsnapper,width=518,height=432,align="center"]

[[fatadaptativonovoxelizer]]
image::fatadaptativonovoxelizer.png[fatadaptativonovoxelizer,width=567,height=352,align="center"]

[NOTE]
.Notas:
====
. http://www.instructables.com/id/Variable-Slicing-for-3D-Printing-on-Autodesk-Ember/[_http://www.instructables.com/id/Variable-Slicing-for-3D-Printing-on-Autodesk-Ember/_]
. http://kalanka.de/blog/adaptive-slicing/[_http://kalanka.de/blog/adaptive-slicing/_]
. https://github.com/platsch/Slic3r/tree/adaptive-slicing[_https://github.com/platsch/Slic3r/tree/adaptive-slicing_]
====
[TIP]
====
__Platsch__, o indivíduo primariamente responsável pelo fatiamento adaptativo no slic3r, é um pesquisador de primeira. Ler o bug report que levou ao fatiamento adaptativo, seu blog e seus relatos em geral são altamente instrutivos, mas um documento mais abrangente e ao mesmo tempo condensado tendo toda a teoria do fatiamento adaptativo assim como uma citação formal das referências você encontra no artigo mais recente dele: Wasserfall, F., Hendrich, N., & Zhang, J. (2017). Adaptive Slicing for the FDM Process–Revisited. 2017 13th IEEE Conference on Automation Science and Engineering (CASE). Pode ser baixado de https://tams.informatik.uni-hamburg.de/publications/2017/Adaptive%20Slicing%20for%20the%20FDM%20Process%20Revisited.pdf
====

=== A Importância da Primeira Camada

[[primeiracamadasethi]]
image::primeiracamadasethi.png[primeiracamadasethi,width=636,height=357,align="center",title="O filete de plástico da mesa mal nivelada (esquerda) é depositado flácido e sem aderência nenhuma com a mesa. Mesmo se essa impressão durar mais do que algumas camadas, em algum momento ela falhará. A mesa bem calibrada, à direita, permite uma primeira camada contínua e bem aderida. Note que a impressão é com ABS, no caso do PLA suas características o fariam ser mais &quot;tolerante&quot; a esse tipo de desnivelamento."]

A altura de camada __da primeira camada__, diferente das camadas da peça inteira, costuma levar diferentes
considerações e tem seu tamanho ajustável de forma independente das outras camadas. Isso acontece porque a
primeira camada é a mais crítica para toda a impressão: ela define quão bem a peça estará aderida à mesa,
portanto quão estável ela ficará durante toda a impressão. Faça uma primeira camada ruim e sua impressão
falhará de alguma forma: no melhor caso, as quinas do objeto levantarão e você terá _warp_ na peça, no pior
caso a peça pode tombar e ser jogada em algum mecanismo da impressora, levando a danos físicos na impressora
ou até acidentes mais sérios.Manter o nivelamento da mesa bem calibrado, com a distância entre a ponta do
bico e a mesa sendo de um cartão de visitas (0,3mm), é essencial para o bom funcionamento da impressora 3D,
assim como manter a mesa perfeitamente horizontal em relação ao plano XY, caso contrário em um extremo da mesa
o bico encostará nela na coordenada Z zero, mas em outro extremo o bico ficará levantado ou afundado. As mesas
de impressora 3D são sustentadas por molas inclusive por causa das situaçõs em que o bico afundaria nelas --
isso dá um tempo de manobra para o operador intervir e impedir danos permanentes ao maquinário.

A situação atual da tecnologia já melhorou bastante em relação a 2009, com procedimentos como regulagens
manuais de parafusos de cada canto sendo cada vez mais raros nas impressoras 3D de hoje. A maioria já adota o
nivelamento automático (com a mais recente Prusa i3 MK2 adotando o refinadíssimo nivelamento de malhas) e ter
a distância do bico para a mesa bem ajustada acaba sendo mais uma questão de ter endstops precisos e um ajuste
de firmware (o deslocamento da sonda do Z) com a medida correta.

Dito isto, é de interesse do usuário saber que o próprio G-Code nunca extruda da coordenada Z zero. Considera-se que
isso seria extrudar plástico completamente encostado na mesa, o que gera pressão extra e pode bloquear e entupir
o bico. O fatiador inicia suas impressões da altura de camada inicial mais um "offset geral" configurável
para a máquina. Não confunda o _offset_ (deslocamento inicial) com a altura da primeira camada, tratada mais adiante.

[[configuracaoslic3rprimeiracamada]]
image::configuracaoslic3rprimeiracamada.png[configuracaoslic3rprimeiracamada,width=626,height=287,align="center",title="A configuração de primeira camada do Slic3r, o offset de Z e o G-Code inicial de um objeto com esses ajustes, com a coordenada 0,4mm em Z ressaltada.  Note que esta configuração foi ilustrativa, na verdade recomendamos deixar o Z offset em zero."]

=== Babystepping

]Um recurso muito útil dos firmwares mais populares (mas não ativado por __default__) é o
__babystepping__, ou __passos de bebê__. É um recurso usado somente em modo interativo, e disponível apenas em
impressoras 3D com LCD e controles, e apesar de disponível para os 3 eixos X, Y e Z, a sua principal utilidade
é para o eixo Z, especialmente por esse ser o eixo com a maior granularidade de posicionamento da maioria das
impressoras 3D do mercado.

O _babystepping_ consiste em corrigir micrometricamente -- para baixo ou para cima -- a altura do extrusor __em
tempo real__, ou seja, __enquanto ele imprime__. Se você começou a impressão e percebeu que o filete não está
saindo tão espremido (ou está tão rente à mesa que o filamento não sai), você pode navegar nos menus do LCD e
selecionar o _babystepping_ para acertar esse posicionamento com precisão bem alta, e salvar a sua impressão. Esse
ajuste de posicionamento não é gravado, e é resetado no primeiro _home_ ou autonivelamento da impressora. A
medida obtida no ajuste fino pode ser depois utilizada como correção no firmware para impressões posteriores.

A utilidade do _babystepping_ é múltipla. Pode obviamente ser usado para impressoras sem autonivelamento que
estejam "um pouquinho fora" da altura ideal, mas também serve para impressoras com autonivelamento com offset
incorreto ou ainda que use sensor de nivelamento de baixa precisão, que às vezes pode obter medidas um pouco
fora das desejadas. Teoricamente ele também poderia ser ajustado para quando a impressora perde passos em um eixo,
mas dificilmente alguém percebe tal momento em uma impressão de múltiplas horas.

Para usar a função de _babystepping_ no LCD (a impressão já tem que ter iniciado):

__Repetier Firmware__: Menu, Quick Settings, Z babystepping, usar o botão rotativo para ajustar.

__Marlin Firmware__: Menu, Tune, dar scroll até Babystep Z, usar o botão rotativo para ajustar.

O Smoothieware não tem _babystepping_ no LCD e não implementa o G-Code `M306` usado para isto, visto
que foge dos padrões de código deles. Ao invés disto, usa um esquema de diferentes sistemas de
coordenadas através do comando `G10 L2`. Mais detalhes podem ser vistos no fórum do smoothieware:
http://forum.smoothieware.org/forum/t-1765243/in-print-z-height-adjustment-babystepping[_http://forum.smoothieware.org/forum/t-1765243/in-print-z-height-adjustment-babystepping_]

Para aparecer nos menus e poder ser usado, o babystepping tem que ser configurado no firmware como ativo e regravado
no microcontrolador da impressora 3D.

=== A altura da primeira camada

Existem duas estratégias diferentes e "quase opostas" para lidar com os ajustes de primeira camada
nos fatiadores. A primeira estratégia envolve configurar uma primeira camada _mais grossa_ que o resto da sua
impressão e funciona bem nos fatiadores que automaticamente reajustam a extrusão de acordo, como o Slic3r e Cura;
por exemplo, se você está imprimindo a 0,2mm, colocar a primeira camada com 0,3mm funciona bem: o filete sairá
mais volumoso, terá maior área de contato, a altura extra absorverá as submilimétricas diferenças que ocorrem
em toda a extensão da superfície, e resto da sua impressão procederá de acordo.

No Simplify3D e outros fatiadores que _não_ reajustam a extrusão de acordo com a altura da primeira camada (sendo
um ajuste à parte), é recomendado que você coloque uma altura de primeira camada __menor__, mantendo a extrusão
dessa primeira camada (referida como extrusion width) a mesma. Assim a mesma quantidade de plástico que ocuparia
0,2mm que é a sua altura de camada principal passa a ocupar 0,1mm, deixando essa camada bem "apertada" na
mesa e portanto com bastante aderência.

[[primeiracamadaslic3rvssimplify3d]]
image::primeiracamadaslic3rvssimplify3d.png[primeiracamadaslic3rvssimplify3d,width=599,height=327,align="center",title="O funcionamento interno do Simplify3D difere do do Cura e Slic3r e o próprio manual dele sugere deixar a primeira camada mais baixa, sem modificar a extrusão, para que ela fique bem apertada."]

Outras técnicas que ajudam uma primeira camada boa:

* **Temperatura mais alta**. Com uma temperatura na mesa mais alta para a primeira camada, está terá maior
viscosidade e ficará mais "chata". Também se pode colocar uma temperatura mais alta para o extrusor, para
garantir "achatamento" e aderência.
* **Menor velocidade**. Isso é essencial especialmente para plásticos
que solidificam mais rápido como o ABS: nas camadas superiores, o plástico sendo depositado estará se fundindo
ao mesmo material abaixo, e suas moléculas têm alta afinidade. Na primeira camada, no entanto, só há a mesa
e um possível adesivo passado por cima dela; o bico pode acabar "arrastando" o filete, principalmente nas
curvas mais fechadas, e plotando uma forma incorreta na mesa que não servirá de apoio adequado para o restante da
peça. A menor velocidade dá mais tempo para o plástico ser depositado no lugar certo. Geralmente uma velocidade
de 20% a 40% da velocidade normal de impressão é recomendada e isso costuma vir como _default_ nos fatiadores.
* **Maior largura de extrusão**. A largura de extrusão é um ajuste que, junto com a altura de camada, pode
ser configurado especificamente para a primeira camada. Se na primeira camada for visível a separação entre os
filetes de plástico, este item (geralmente uma porcentagem) deve ser aumentado. Veja que o fatiador "compensa"
a largura maior aumentando a quantidade de plástico (e também separa mais as linhas, em proporção), de modo
a evitar que a mesa se inunde de plástico.
* **Colas e adesivos**. Materiais mais difíceis como policarbonato,
poliacetal e HDPE podem não funcionar bem nem com os ajustes anteriores. Nessa hora, certos adesivos específicos
podem ajudar bastante. Desde cola branca escolar até produtos feitos especificamente para impressão 3D (A.Bond,
Spray Cliever e outros), as opções são variadas aqui. É importante verificar a compatibilidade química do
adesivo considerado com o material que deseja trabalhar.
* *Brim* (bainha) e *Raft* (balsa): são estruturas
auxiliares que você define no fatiamento e, junto com as outras que apresentaremos, são o tema do próximo
capítulo.

== Estruturas auxiliares

Partindo do pressuposto (nem sempre verdadeiro) que a matéria-prima da impressão 3D é barata, nem sempre a peça
que retiramos da mesa de impressão estará em sua forma final. Dificuldades pragmáticas como aderência à mesa,
estruturas pendentes, geometrias difíceis, fragilidade ao calor acabam tendo soluções em estruturas temporárias
que são fabricadas em conjunto com a peça, para serem posteriormente destacadas e descartadas (ou, melhor ainda,
recicladas como novos carretéis de filamento).

[TIP]
.Prime
====
O __Prime__, também chamado de __Priming__, é o nome dado às variadas estratégias de início de impressão para
ter o bico da impressora "limpo" dos fragmentos de plásticos ou sujeira e também para começar a extrudar
plástico uniformemente.
====

=== *Skirt (saia)*

[[exemploskirt1]]
image::exemploskirt1.png[exemploskirt1,width=642,height=196,align="center"]

A idéia desta estrutura -- uma das desempenhar a função de "prime" -- é literalmente desperdiçar filamento
antes de iniciar a impressão: o _skirt_ nada mais é que um contorno da primeira camada da peça, separado desta
primeira camada. Você o configura colocando a distância da peça e o número de voltas. Ocorre que quando se insere
um novo carretel no extrusor da impressora 3D, o extrusor não começa inicialmente a depositar plástico. O momento
em que o plástico derretido começa a sair é sujeito a algumas variáveis e portanto levemente indeterminado;
extrudar uma ou duas linhas de plástico antes de começar a própria peça garante que a deposição já terá
iniciado. O skirt é útil para outras finalidades: ajuda a visualizar se há algum desnivelamento da mesa e também
realiza __priming__, que é purgar o plástico derretido que pode estar presente no bico de extrusões passadas. Como
a quantidade de filamento que desperdiça é realmente muito pequena, é altamente recomendado que se o utilize sempre.

=== Brim (bainha)

[[exemplobrim1]]
image::exemplobrim1.png[exemplobrim1,width=642,height=196,align="center"]

Já vimos que a aderência à mesa é um problema atacado por várias estratégias, e o brim vem se somar a
elas. Consiste em fazer um contorno chato ligado à peça que aumenta a _superfície de aderência_ da peça em
contato com a mesa. Assim, a força de aderência total fica maior, e a peça mais firme. A bainha também _canaliza_
o warp, sendo a primeira estrutura a se deformar, atrasando assim que a parte mais interna -- a própria peça
-- sofra seus efeitos.

O aspecto negativo da bainha é que ela tem que ser destacada no final. Para peças com seções grandes, não
costuma ser um problema; para peças com seções finas ou delicadas em contato com a mesa, a bainha pode ser mais
difícil de tirar sem quebrar algo. Geralmente as arestas restantes da bainha são fáceis de remover com estilete
ou rebarbadeira manual.

Alguns fatiadores tornam o _skirt_ e o _brim_ uma configuração só, bastando para ter o brim configurar a
distância da estrutura para a peça igual a zero.

[NOTE]
.Nota:
====
diferente de outros fatiadores, o Simplify3D não usa a velocidade de primeira camada para o brim, usando a
velocidade "normal" e podendo não aderir bem na mesa. Enquanto não se conserta essa idiossincrasia do fatiador,
um jeito de mitigá-la é usar _processos separados_ para a primeira camada e o resto da impressão. Falaremos
sobre isso mais à frente.
====

[TIP]
====
*Orelhas do Mickey* ou *Abas* -- o usuário pode olhar para o modo como o brim funciona e se perguntar: se o warp
tende a se concentrar nos cantos e regiões pontiagudas, por que não existe uma opção no fatiador para fazer
bainha somente nelas, economizando plástico e tempo de impressão? A razão é que essa análise de geometria é
complexa e sujeita a casos de falha. Isso não evitou que algumas pessoas modelassem elas mesmas essas estruturas
-- batizadas carinhosamente de __mouse ears__, orelhas de camundongo, e colocassem no seu modelo.
[[mouseears1]]
image::mouseears1.png[mouseears1,width=633,height=451,align="center",title="Um design to thingiverse que incorpora &quot;mouse ears&quot; automaticamente no modelo, não sendo necessário ligar o brim. Referência: http://www.thingiverse.com/thing:66030"]
[[mouseearsopenscad]]
image::mouseearsopenscad.png[mouseearsopenscad,width=612,height=442,align="center",title="É facílimo criar você mesmo um modelo de &quot;mouse ears&quot;, aqui um exemplo no software open-source openscad da estrutura com 20 mm de raio e 0,3mm de altura. Coloque na bandeja do fatiador, sobreponha aos cantos e imprima (em fatiadores como o Cura, a prevenção de colisão precisa estar desligada)."]
====
=== Raft (balsa)

[[raftbalsaiogurtedebacalhau]]
image::raftbalsaiogurtedebacalhau.png[raftbalsaiogurtedebacalhau,width=642,height=299,align="center",title="Configurações de raft no Slic3r. Exageramos um pouco a altura para o raft ficar visível na pré-visualização: geralmente se usam entre 2 a 4 camadas apenas, usamos 10. No Slic3r, as camadas de raft obedecem à configuração geral de camada; outros fatiadores, como o Simplify3D, usam camadas de valores diferentes para tentar dar maior estabilidade à estrutura."]

Este nome um tanto cômico na verdade reflete a aparência da estrutura: é como se houvesse uma estrutura de troncos
e galhos elevando um pouco a peça e funcionando como uma "bóia" em relação à plataforma de impressão. E
é esta a idéia geral da estrutura: oferecer uma superfície "fofa" e adesiva em cima da qual a peça se torne
estável para a impressão. Nas impressoras FDM industriais, o _raft_ é sempre usado, muitas vezes de material
diferente em impressoras com dois extrusores (é mais facilmente destacado).

O _raft_ também serve para aderência, mas perceba que ele é bem diferente do brim. O _brim_ é um reforço
lateral e não levanta a peça, o _raft_ fica por baixo dela. O _brim_ é contínuo, o _raft_ é mais "esparso" e
portanto não tem uma superfície de contato tão grande com a mesa. A característica de ser "esparso" advém
de o _raft_ compartilhar configurações com as estruturas de suporte, que é a que explicaremos a seguir.

=== Deixando de ser insuportável

Já tratamos do problema da _estruturas pendentes_ quanto falamos sobre as malhas. Reiterando o que dissemos,
partes do lado de baixo da peça que têm inclinação próxima da horizontal ou que aparecem "soltas" no
espaço em relação à mesa precisarão, durante a impressão, de _suporte_ como pilares de sustentação abaixo
delas. Esse suporte precisa ser facilmente destacável após o término da impressão e idealmente também não
deve atrasar muito a impressão da peça nem gastar muito material.

Tradicionalmente, as estruturas de suporte automático, nos fatiadores, usam duas configurações principais:
o _ângulo mínimo_ em relação à vertical para o suporte ser colocado e o __padrão__, isto é, que forma
esparsa os pilares terão, já que não serão totalmente preenchidos.

[[suportenaotemespinhas]]
image::suportenaotemespinhas.png[suportenaotemespinhas,width=632,height=633,align="center",title="Diferentes ângulos de suporte e seus efeitos no Slic3r. Tratar todos os itens de configuração automática dos fatiadores é um trabalho inglório, pois essa é uma das configurações que mais variam entre eles. Por exemplo, no Slic3r a quantidade de suporte aumenta com o ângulo mínimo, mas com zero no campo ele não se fia mais no ângulo e usa análise da geometria para decidir com certa inteligência onde colocar. Pode-se ver no diálogo de configuração dele ainda que existem diversos campos tratando da distância de contato e camadas de interface - configurações não presentes em outros fatiadores e que anos após sua introdução, se mostraram ineficazes e difíceis de entender (a próxima versão do fatiador surgirá com essa parte refatorada)."]

Suportes são estruturas "detestadas mas necessárias" no mundo da impressão 3D. Muitas vezes colocadas
pelo fatiador em uma área de difícil alcance, ou mesmo desnecessária, são um estorvo que leva muita gente a
comprar instrumentos variados para facilitar sua remoção, de cortantes a de pressão, multiplicando os acidentes
relacionados à área. Não é à toa que os cursos de modelagem para impressão 3D têm uma enorme parte teórica
dedicada a geometrias que evitem colocação de suportes e que na impressão 3D industrial a extrusão múltipla
utilizando filamentos dissolvíveis, embora encareça consideravelmente o processo, torna-se algo tão favorecido
especialmente para as formas mais rebuscadas.

[[suporteexageradoesemsuporte]]
image::suporteexageradoesemsuporte.png[suporteexageradoesemsuporte,width=616,height=371,align="center",title="À esquerda: &quot;puxa, não precisava exagerar...&quot; Muitas vezes a colocação de suportes é desnecessária. Deve ser usada com parcimônia, o mínimo possível para ter qualidade, visto que o trabalho de remoção posterior pode ser enorme. À direita: o dragão cantor &quot;Aria&quot;, uma peça modelada especificamente para a impressão 3D, sem nenhum &quot;overhang&quot; acentuado, podendo ser impressa sem suporte. As duas peças impressas com raft, que acabou permanecendo como uma espécie de &quot;pedestal&quot;."]

Um destaque especial para um "macete" de qualidade: até a versão 1.2.9, os suportes do Slic3r
são lentos e rebuscados, não funcionando tão bem quanto os de outros fatiadores. Como muitos
softwares livres de amplo alcance, entretanto, ele sofreu um _fork_ (uma derivação e desenvolvimento
independente) pelo pessoal da __Prusa Research__, que faz as impressora 3D Prusa. Esta derivação do
Slic3r tem algumas diferenças e novidades interessantes, e uma delas é a melhora do padrão default
("rectilinear") e o surgimento da opção que permite remover o __sheath__, a parede de separação
do suporte. Sem o sheath, o suporte, sendo em sanfona, fica muito mais fácil de remover da peça, então
esta configuração é altamente recomendada. O slic3r modificado pode ser baixado do site da Prusa Research -
http://www.prusaprinters.org/introducing-slic3r-prusa-edition/[_http://www.prusaprinters.org/introducing-slic3r-prusa-edition/_]
- ou do repositório deles do github -- https://github.com/prusa3d/Slic3r[_https://github.com/prusa3d/Slic3r_]. Note
que essas diferenças e novidades da versão "prusa", no momento de criação deste livro, já estão sendo
incorporadas ao Slic3r "oficial", e possivelmente estarão disponíveis no momento em que você, leitor,
o estiver lendo.

[[slic3rprusasuportes]]
image::slic3rprusasuportes.png[slic3rprusasuportes,width=642,height=764,align="center",title="Slic3r da Prusa Research com suas opções extras de suporte, e as recomendadas para um suporte facilmente removível."]

==== Um toque pessoal: os suportes de colocação manual

Dados os reveses dos suportes, e que suas configurações nem sempre são suficientes para assegurar uma colocação
automática boa ou mesmo passável, os programadores do fatiador Simplify3D implementaram uma _excelente_ solução
que ainda é, hoje, o seu principal diferencial: a colocação manual de suportes. Funciona assim: você pode
usá-lo como os outros fatiadores e simplesmente configurar o ângulo mínimo para o suporte automático, e se
ele deve ou não gerar o suporte. Mas você pode chamar um painel específico para ver como os suportes ficarão,
e através deste painel pode zerar os suportes da peça, remover partes do suporte ou adicionar suportes onde o
fatiador não colocou. Embora este procedimento possa necessitar de uns minutos de dedicação, não se compara aos
riscos e potencialmente horas perdidas de remoção física de suporte, ou do custo de filamento dissolvível. Para
arrematar, fisicamente o próprio suporte do Simplify3D é um dos mais fáceis de destacar da peça, usando um
padrão de sanfona que preserva melhor a qualidade das superfícies que apóia e que faz com que todo o suporte
saia de uma vez só quando puxado.

[[simplify3dsuportesmanuais]]
image::simplify3dsuportesmanuais.png[simplify3dsuportesmanuais,width=603,height=437,align="center",title="O painel de colocação de suportes manuais do Simplify3D, com a visualização de uma peça especialmente difícil de suportar."]

De fato, haja visto essa solução muito boa para o problema, o leitor pode se perguntar: por que nem todos os
fatiadores a adotaram? A melhor resposta é que este recurso necessita de algoritmos complexos e uma sintonia fina
de interface e os desenvolvedores de outros fatiadores por isso _ainda_ não o implementaram. Além do Simplify3D,
outros fatiadores para impressoras FFF do mercado que permitem a colocação manual de suportes são o CraftUnique
Craftware e o Raise3D Ideamaker. Ambos são proprietários, mas pelo menos também são multiplataforma (Mac OS X,
Linux e Windows).

[[craftwaresuportesmanuais]]
image::craftwaresuportesmanuais.png[craftwaresuportesmanuais,width=517,height=480,align="center",title="Uma alternativa gratuita ao Simplify3D (ainda que não open-source), também oferecendo o recurso de suportes manuais."]

[[ideamakersuportesmanuais]]
image::ideamakersuportesmanuais.png[ideamakersuportesmanuais,width=566,height=407,align="center",title="Outro fatiador gratuito e proprietário que oferece colocação manual de suportes, o Raise3D Ideamaker."]

Uma outra opção gratuita e proprietária é o software _Meshmixer_ da Autodesk. Diferente dos citados, ele não é
um fatiador; ele é um __editor de malhas__, um software feito para auxiliar no tratamento de malhas para impressão
e também com capacidades limitadas de modelagem. Similar ao Meshmixer a Autodesk oferece também o _Print Studio_
com a mesma capacidade de fazer suportes automáticos, apesar de menor configurabilidade.

[[meshmixersuportesmanuais]]
image::meshmixersuportesmanuais.png[meshmixersuportesmanuais,width=603,height=582,align="center",title="O Meshmixer permite variados padrões de suporte, incluindo suportes &quot;em árvore&quot; e diagonais, que potencialmente economizam mais filamento mas podem ser mais difíceis de dominar. Depois de gravar como STL, os suportes não se tornam mais editáveis: passam a fazer parte do modelo. É preciso ainda se lembrar de desativar o suporte no fatiador, já que ele estará incorporado à forma."]

Outro modo de colocar suportes personalizados -- ou removê-los -- é o usado pelo fatiador *Cura* em sua versão
2.4.0: ele permite que se definam certas malhas como __malhas de modificação de suporte__, tanto para forçar
suporte naquele volume ("Support Mesh") como para forçar que ele não apareça ("Anti Overhang Mesh").

[[curasuportesmanuais]]
image::curasuportesmanuais.png[curasuportesmanuais,width=642,height=558,align="center",title="Personalização de suporte no Cura. Toda a parte direita da peça está suportada, mas à esquerda foi carregado um cubo e definido como &quot;anti overhang mesh&quot; (malha de modificação) em que suportes não serão impressos. Na Ilustração, O Anti Overhang Mesh está desmarcado porque é um ajuste de objeto individual dado ao cubo, não ao cogumelo. Nota: esse truque só é viável com a opção &quot;Ensure Models Are Kept Apart&quot; desligada nas opções gerais, senão o fatiador não deixa as peças sofrerem interseção."]

=== A cobertura de escorrimento

Essa estrutura tem vários nomes diferentes em inglês como __draft shield__ e __ooze shield__, todos difíceis de traduzir: "cobertura de trabalho" e "escudo de escorrimento" seriam algumas possibilidades. É implementada com ligeiras variações entre os
fatiadores, o conceito geral sendo um "campo", "cobertura" ou "paredes" em torno do objeto e com pelo
menos duas finalidades diferentes: capturar o escorrimento (__ooze__) excessivo do bico quando se usa dupla extrusão
ou filamentos menos viscosos, _ou_ formar um "domo" em volta da peça para aprisionar o ar quente e ajudar a
prevenir o warp. Quando o objetivo é este último, geralmente a estrutura acompanha ou se molda ao contorno vertical da peça, quando é o primeiro a estrutura é completamente vertical.

Alguns fatiadores não têm esta estrutura, mas ela pode ser aproximada configurando um _skirt_ com a altura da peça.

[[draftshieldazullindao]]
image::draftshieldazullindao.jpeg[draftshieldazullindao,width=618,height=516,align="center",title="Um draft shield sendo impresso junto com uma peça. A foto também apresenta em sua parte inferior o brim com levantamento de quina pelo warp."]

=== Pilares de escorrimento / prime / purga

Assim como o __ooze shield__, o pilar de escorrimento, torre de purga ou torre de _prime_ serve como alternativa para descartar
filamento escorrido e limpar o bico a cada camada impressa. É bastante usado em extrusão dupla porque nesta um
bico é utilizado por vez, e o bico não ativo tende a deixar escorrer filamento. Se o ooze shield estiver causando
problemas na peça, o pilar pode ser uma boa alternativa.

[[curapilardeescorrimento]]
image::curapilardeescorrimento.png[curapilardeescorrimento,width=615,height=484,align="center",title="Uma configuração de extrusão dupla no Cura mostrando o pilar de escorrimento ao fundo. Neste fatiador a estrutura tem o nome de &quot;Prime Tower&quot;."]

=== Bridges (pontes)

Um caso em que se tem estruturas pendentes onde os suportes não seriam tão úteis ou até atrapalhariam são
as __pontes__. A ponte é uma estrutura cuja parte superior é completamente horizontal (sem material abaixo)
e relativamente curta. A maioria dos fatiadores consegue detectar tal situação e como tal pode ser configurado
para, ao invés de produzir suporte abaixo dela, tentar produzir o filete mais horizontal possível, regulando
velocidade e extrusão (tipicamente maior velocidade e menos extrusão, "esticando" o filete e evitando que
colapse). A regulagem deste tipo de comportamento dependerá bastante do filamento, das temperaturas e das dimensões
escolhidas. Alguns integrantes do _thingiverse_ e outros websites de compartilhamento de formas 3D compartilham
"testes de tortura de pontes", para você testar os limites de sua impressora com essas estruturas. Um dos
mais clássicos é o do usuário __Triffid Hunter__, integrante ativo do projeto reprap.

[[pontestestedetortura]]
image::pontestestedetortura.png[pontestestedetortura,width=633,height=577,align="center",title="&Teste de tortura& clássico para atestar qualidade de pontes. Fonte: http://www.thingiverse.com/thing:12925"]

[[ponteseleao]]
image::ponteseleao.jpeg[ponteseleao,width=642,height=257,align="center",title="Um exemplo criativíssimo do uso de pontes. Uma peça feita com um cilindro externo em que várias pontes terminam, começando da cabeça do leão. No final da impressão o cilindro é cortado fora da peça e os &cabelos& resultantes são então abaixados com uma pistola de ar quente. Fonte em http://www.thingiverse.com/thing:2007221"]

[[slic3rpontes]]
image::slic3rpontes.png[slic3rpontes,width=623,height=527,align="center",title="As configurações de ponte do slic3r se encontram espalhadas pelas categorias. Esse screenshots têm configurações recomendadas: velocidade nas pontes ligeiramente maior que a de impressão, conjugada a menor fator de extrusão (0,92) para &quot;esticar&quot; o filete que ligará dois pontos; e ventoinha do bico ligada a 100% na ponte, para garantir que o plástico seja solidificado o mais rápido possível."]

== Configurações de Qualidade

Os conceitos que aprendemos até agora são essenciais para a _viabilidade_ da impressão. Uma vez que aprendemos
tais requisitos, estamos prontos para aquela parte que torna o fatiamento algo semelhante a uma arte: os ajustes
que, quando equilibrados de maneira calculada e harmoniosa, contribuem para dar à peça o acabamento, aparência
ou propriedades desejadas.

=== O Preenchimento

Nesta altura do aprendizado, o leitor já tem noção que as peças impressas em 3D não precisam ser totalmente
sólidas, preenchidas: é desperdício de material, não contribui muito para a resistência e torna a peça
desnecessariamente pesada. Assim como no caso do suporte integrado que vem em alguns STL, existem peças que já
vêm modeladas ocas para não gastar muito material. Mas, claro, isso não é necessário: uma das configurações
mais flexíveis que todo configurador tem é o preenchimento interno da peça, _infill_ em inglês.

O ajuste mais importante do infill é a __porcentagem__. Esta porcentagem é a quantidade de material no espaço
interno da peça que será ocupado: 0% sendo nenhum material (totalmente oca) e 100% sendo totalmente maciça. Para
os valores entre 0 e 100, o fatiador empregará o segundo ajuste, que é o __padrão de preenchimento__, uma
estrutura repetitiva. Um terceiro ajuste do preenchimento é o ângulo em relação ao eixo X da mesa, e serve
para que o preenchimento não coincida com a orientação da peça, tendo uma distribuição melhor de forças.

[[slic3rpreenchimentos1]]
image::slic3rpreenchimentos1.png[slic3rpreenchimentos1,width=626,height=534,align="center",title="Diferentes padrões e porcentagens de preenchimentos do Slic3r. Os nomes foram mantidos em inglês para que o leitor possa achar as opções. Note que os preenchimentos estão em ângulo de 45° em relação ao eixo X, perceptível pelo Rectilinear."]

O Slic3r e Simplify3D permitem grande variedade de padrões de preenchimento. A maioria dos casos no entanto tem
mais valor ornamental e não contribui muito para melhorar propriedades desejáveis da peça. O Slic3r permite
até padrões diferentes na horizontal e vertical. Alguns casos que são notáveis de padrões são:

* **Retilinear** ou **quadrático**: é o que oferece melhor retorno resistência a força vs. rapidez de impressão. É o
default em virtualmente todos os fatiadores.
* **Honeycomb** (colméia) ou **hexagonal**: é tido como um preenchimento que
oferece uma ótima distribuição de forças, e na natureza aparece em estruturas que precisam disso. Na impressão
3D, entretanto, os primeiros testes de força feitos com preenchimentos, usando PLA, não encontraram diferenças
significativas em relação ao retilinear, e ele é impresso consideravelmente mais devagar.
* **Triangular** é adequado
para uso com filamentos flexíveis; preserva a elasticidade desejada na parte interna do objeto.
* **Concêntrico** é
interessante para uso com filamentos transparentes e translúcidos que precisam preservar a aparência interna suave.

Em uso geral para impressão 3D, o recomendado é usar uma porcentagem de preenchimento entre 10 a 30%, aumentando
só para os casos específicos em que maior robustez for desejada. 100% deve ser evitado porque nesse caso ao invés
de um padrão de preenchimento, uma trajetória sólida é aplicada, sem a sobreposição e trançamento de filetes
que dá resistência à peça. O peso também depõe contra a resistência do material. Para resistência máxima,
geralmente os por volta de 80% é suficiente.

O preenchimento é importante para a resistência do objeto, e a sua contraparte nessa empreitada é a configuração
de __paredes__, que deve ser levada em consideração em conjunto.

Os fatiadores *Cura* e *Slic3r* resolvem ainda um problema relativo a preenchimento "oco" (0%). A desvantagem
óbvia de você zerar o preenchimento e tentar imprimir uma peça só com a configuração de paredes (como
veremos abaixo) é que comumente se tem "overhangs" (seções pendentes) internas; com o preenchimento zero,
se a geometria não for adequada elas desabariam. O Cura tem um "modo oco" (__Hollow Out Objects__) que zera
o preenchimento, mas analisa o interior da peça oca para colocar suportes, garantindo a impressão adequada da
peça. O Slic3r tem a configuração Print Settings → Infill → Reducing printing time → "Only infill where
needed", que força preenchimento zero mas coloca suportes nas partes internas com seções pendentes.

[[curamodooco]]
image::curamodooco.png[curamodooco,width=642,height=487,align="center",title="&quot;Modo oco&quot; do Cura com a peça com preenchimento zero, mas suportes internos para as seções pendentes."]

Alguns fatiadores permitem ainda fazer o preenchimento com altura de camada diferente do resto da impressão. Neste
caso, a altura de camada do preenchimento precisa ser múltipla da altura de camada da impressão -- digamos,
0,1mm para a impressão e 3 vezes isso para o preenchimento, 0,3mm. Isso faz com que a impressão demore bem menos
e ainda fique ligeiramente mais robusta. Seguindo o exemplo de 0,1mm e 0,3mm, o jeito de fazer isso em cada fatiador
é ligeiramente diferente:

* **Slic3r**:
** Print Settings → Layers and perimeters → Layer height: [**0.1**] mm;
** Print Settings →
Infill → Reducing printing time → Combine Infill every: [**3**] layers
* **Simplify3D**:
** Layer → Primary Layer Height: [**0,1000**] mm;
** Infill → General → Print Sparse Infill Every [**3**] Layers
* **Cura**:
** Quality → Layer Height [**0.1** mm]
** Infill → Infill Layer Thickness: [**0.3** mm]

É importante notar que esse ajuste pode facilmente levar a situações absurdas, que podem até estragar a
impressão. Por exemplo, se você tem um bico de 0,4mm, sua altura de camada for 0,3mm e você pedir o preenchimento
esparso a cada 3 camadas, você estará pedindo ao fatiador que faça as camadas de preenchimento com 0,9mm de
altura, algo totalmente fora da margem de extrusão razoável de um bico de 0,4mm. O filete para preenchimento
sairá completamente espirrado e torto e possivelmente nem se assentará em cima da camada anterior.

=== Paredes

Este ajuste se refere ao número de filetes ou camadas sólidas que o fatiador vai fazer antes de aplicar o padrão
de preenchimento. A denominação varia entre os fatiadores e mesmo neles para os que tratam como paredes laterais ou
do topo (__top__) e da parte de baixo (__bottom__). Alguns fatiadores usam para as paredes _o número de "voltas"
(perímetros)_ (nas paredes verticais) ou _camadas_ (nas paredes horizontais), outros usam _a espessura esperada_
(por exemplo, 0,8mm).

* **Slic3r**: paredes laterais são dadas em perímetros: __vertical shells -- perimeters__. Do topo e da
parte de baixo são dadas em camadas e __horizontal shells -- Solid layers Top & Bottom__.
* **Cura**: paredes
laterais são _wall thickness_ (espessura de parede). Do topo e da parte de baixo são _Top/Bottom Thickness_
(espessura superior/inferior). Podem ser dadas tanto em número de perímetros/camadas quanto em milímetros, o
fatiador popula o campo de acordo.
+
image::image364.png[image,width=618,height=268,align="center",title="O Cura permite preencher ou a espessura desejada da parede ou o número de linhas (perímetros). Se você preenche um campo, ele popula o outro automaticamente."]
+
* **Simplify3D**: paredes laterais são __Outline/Perimeter Shells__. Do topo e da barte de baixo são _Top Solid Layers_ e __Bottom
Solid Layers__. São sempre dados em números de filetes / camadas.
* Outros fatiadores terão suas próprias
nomenclaturas, mas a partir destes exemplos é possível inferir quais sejam.

[[slic3rdiferentesperimetros]]
image::slic3rdiferentesperimetros.png[slic3rdiferentesperimetros,width=620,height=504,align="center",title="Exemplo de diferentes larguras de paredes laterais (perímetros) no Slic3r. Veja que aqui tratamos somente das laterais, pois é mais difícil ilustrar os casos de paredes do topo e da parte de baixo das estruturas."]

Seguindo a indicação para FFF de espessuras mínimas para resistência (entre 1 e 2 mm), podemos inferir que
para um bico de 0,4mm e altura de camada de 0,2mm uma boa espessura lateral seriam 4 filetes (0,4 x 4 = 1,6mm)
e espessuras de topo e de baixo de 8 camadas (8 x 0,2 = 1,6mm). Para muitas peças, especialmente as decorativas,
essa espessura de camada é tão adequada que o preenchimento pode nem ser necessário.

Vale lembrar que tanto as paredes quanto o preenchimento contribuem para mais material condensado e portanto mais
pronunciado será o efeito de __warp__.

=== Larguras de camada

Um ajuste que vimos para aumentar a aderência na mesa foi a "largura de camada". Apesar de ser possível ajustar
para a primeira camada especialmente, ele pode ser especificado para todas as camadas do fatiamento. Geralmente
o fatiador faz o cálculo automático da largura de camada "ideal" a partir do diâmetro do bico, e pode
mantê-lo constante ou variá-lo durante a impressão para melhorar a qualidade da peça. O Simplify3D, por exemplo,
considera que a largura do filete é de 20% maior que o orifício -- 0,48mm para um nozzle de 0,4mm; o slic3r usa
uma fórmula complexa^1^ para calcular isso -- resultando em 0,67mm para um nozzle de 0,4mm com altura de camada 0,2
e 0,48 para altura de camada 0,3 -- e 5% maior que o bico para o filete _externo_ (a parede mais externa). Com até
mesmo os fatiadores discordando entre si, não é surpresa que eles permitam que o ajuste seja personalizado. É
importante notar que o fatiador ainda confia na quantidade de plástico correta configurada: se você aumenta a
largura de camada, ele extrusa mais plástico e também tece menos segmentos (a impressão demorará menos).

Se sua impressão estiver saindo com as linhas "não se tocando", o primeiro suspeito é a taxa de extrusão
baixa, mas pode ser também uma largura de extrusão menor que a real. Nesse caso:

* **Para resolver filetes distantes**, _aumente_ a largura de extrusão.
* **Para resolver filetes apertados ou encavalados demais**, _diminua_ a largura de extrusão.

[[simplify3dlarguradeextrusao]]
image::simplify3dlarguradeextrusao.png[simplify3dlarguradeextrusao,width=642,height=408,align="center",title="O Simplify3D permite configurar uma única largura de extrusão; o slic3r tem configurações para várias ocasiões e gersalmente faz cálculos sofisticados de acordo com a velocidade, extrusão e temperatura. Isso permite, com alguns ajustes mais elaborados, ter as seções pequenas de peças muito mais detalhadas e colocar o plástico mais interno com maiores camadas, tanto para reforço como para velocidade."]

__*Nota de configuração*__: o Slic3r permite ajustar as larguras de camada tanto em valor absoluto (por exemplo,
0,4mm) quanto porcentagem (por exemplo, 200%). Mas porcentagem _de quê_ exatamente? Intuir-se-ia ser o diâmetro do
nozzle, mas não é; a porcentagem entrada nos campos de largura de camada é em relação à **altura de camada**. Se
você tiver por exemplo altura de camada 0,1mm e colocar a _default extrusion width_ em "200%", você está
dizendo ao Slic3r que a espessura do filamento é 0,2mm; e se de repente mudar para 0,3mm e se esquecer de mudar na
largura de camada, o fatiador passará a assumir o valor 0,6mm. De fato, esta configuração é tão anti-intuitva
que se aconselha a nunca usar porcentagens, apenas valores absolutos. No _bugtracker_ do slic3r, existe um relato
de bug para isso: https://github.com/alexrj/Slic3r/issues/3658[_https://github.com/alexrj/Slic3r/issues/3658_]

[NOTE]
.Nota:
====
1 -- A fórmula do Slic3r é, onde __w__ = largura de extrusão calculada, __d__ = diâmetro do bico e __h__ = altura de
camada: `w = (π.d^2^ + (4-π).h^2^)/(4h)`, com o valor de __w__ limitado ao máximo de __3×d__.
====

image::image367.png[image,width=642,height=437,align="center",title="Diferentes larguras de camada no slic3r e Simplify3D. Em sequência: largura default(com nozzle de 0,4mm), largura configurada para 0,4mm e largura configurada para 0,8mm. Na visualização é possível notar que as larguras mais grossas têm menos segmentos e o fato de eles serem mais &quot;grossos&quot; é porque o fatiador calcula o volume de extrusão para aumentar de acordo."]

=== Ventilação

A ventilação no fatiador se refere às ventoinhas que podem ter sua intensidade controlada pela placa da impressora;
geralmente apenas uma, soprando o bico ou bicos do extrusor, conforme vimos no capítulo sobre extrusores. Portanto,
se refere a uma situação muito particular em que estamos tratando de um filamento com baixo warp e baixo ponto
de transição vítrea, que necessita de refrigeração forçada para apresentar boa qualidade de superfície.

A configuração dos fatiadores costuma ser mais do que suficiente para tratar todos os casos, até exagerada. Se
dividem em dois:

* Quando o filamento é realmente *muito* dúctil e propenso a "desabar". Neste caso, haverá uma configuração
de simplesmente "deixar a ventoinha ligada o tempo todo".
* Quando o filamento é medianamente dúctil, só
"desabando" nas partes mais delicadas como pontes e overhangs. Neste caso, basta deixar os ajustes automáticos
do fatiador em seus valores __default__.

[[slic3rventilacao]]
image::slic3rventilacao.png[slic3rventilacao,width=502,height=465,align="center",title="Valores default do resfriamento automático do Slic3r. O Slic3r associa as configurações de resfriamento a um filamento específico, mas em outros fatiadores pode ser mais importante se recordar de desligar a ventoinha ao se trabalhar com ABS ou outros filamentos propensos ao warp."]

=== Velocidades

À primeira vista, a configurabilidade de velocidades da impressora pode parecer estranha ao marinheiro de primeira
viagem; se é possível colocar valores arbitrários para as velocidades dos movimentos da impressora 3D, por que
não deixar tudo o mais rápido possível e terminar uma impressão em segundos ao invés de horas? A resposta,
como no caso das alturas de camadas, é topar com limite físico: os primeiros a considerar são a rapidez
do microcontrolador e do motor. O que se traduz em "velocidade" para o motor é quantos "cliques" o
microcontrolador envia para ele por segundo e microcontroladores Arduino têm um limite de cliques equivalentes a
pouco mais de 300 mm/s; e os motores terão também uma capacidade de velocidade relacionada ao torque, corrente
e estruturas internas. Se o microcontrolador enviar mais ordens de velocidade do que ele está preparado, ele pode
simplesmente não girar e perder a referência (pois não é "servo motor").

Mas mesmo desconsiderando a limitação de processamento, que teoricamente se resolveria comprando microcontroladores
mais rápidos (a alimentação também precisaria se readequar), outros limites físicos têm relação com a
estrutura da impressora, vibrações e qualidade de impressão. Até o atrito com os rolamentos pode fazer diferença
nesse caso, e velocidades muito altas terão efeitos como fazer a impressora vibrar, "sacudir" a peça no caso
de mesas móveis, gerar inércia que tende a criar artefatos na impressão. Para o profissional de impressão 3D,
colocar uma velocidade mais alta pode acabar significando tempo perdido com peças sub-ótimas, risco de artefatos
indesejáveis e de "perda de passo" do motor, não valendo a pena. Claro que existem impressoras 3D no mercado
construídas para aguentar maiores velocidades, mas aí estamos tratando das exceções e não da regra.

A orientação geral que costuma servir para a maioria das impressoras 3D é uma velocidade principal (de perímetro)
de 60 mm/s. Velocidade principal porque dependendo do fatiador existem várias outras velocidades configuráveis:
a velocidade do carro quando não se está imprimindo (velocidade de "travel", ou "percurso") pode ser
tão alta quanto a impressora aguente; o preenchimento e suportes não precisam ter muito boa qualidade, então
é comum haver uma velocidade maior para eles; do mesmo modo, seções transversais muito pequenas, pelas curvas
fechadas que apresentam, podem precisar de menor velocidade; pontes, como já vimos, podem ser programadas para
ter uma velocidade maior, para esticar o filamento; e a velocidade do eixo vertical, que geralmente é com fuso
ou barra roscada, pode ser limitada para evitar perda de passos dos motores.

Velocidade ainda não é o único fator em questão. O eixo não vai partir diretamente da posição estática para a
velocidade destino: ele tem uma aceleração mensurável até alcançar aquela velocidade. Estas acelerações também
são configuráveis. Tradicionalmente, são configuradas como acelerações máximas no próprio firmware da máquina,
sem interferência do fatiamento. Mas a tendência atual é de os fatiadores incorporarem essa configuração, o que
lhes ajuda na previsão correta do tempo de impressão total. E a configurabilidade não pára nas acelerações:
existe ainda um ajuste relacionado à velocidade máxima em mudança de direção, o "jerk", que começa
também a ser movido do firmware para o fatiador.

As estratégias de como lidar com esses ajustes também muda de acordo com o fatiador. O Simplify3D limita as
velocidades configuráveis ao mínimo, e emprega especial atenção aos seus algoritmos internos (heurística)
para tomar as decisões; o Slic3r tem muitas velocidades e acelerações configuráveis, mas também tem um
recurso chamado de "autospeed" (autovelocidade) que calcula as velocidades ideais em cada caso para deixar
a pressão interna do hotend a mais constante possível; o Cura simplesmente permite que o usuário decida tudo,
deixando todas as configurações ao alcance. Pode ser enlouquecedor lidar com tantas configurações.

[[slic3recuravelocidades]]
image::slic3recuravelocidades.png[slic3recuravelocidades,width=616,height=407,align="center",title="À esquerda: painel de velocidades do Slic3r, com todos os ajustes exibidos (e com o controle de aceleração desligado); à direita: alguns dos ajustes relacionados a velocidade do Cura - simplesmente não cabem todos na tela."]

O melhor a fazer para saber velocidades boas para sua impressora 3D é recorrer à fonte -- o fabricante. Grupos
de discussão, facebook e semelhantes relacionados ao produto também podem ter dicas de usuários aventureiros que
se arriscaram com impressões mais rápidas e preservaram qualidade. Para não deixar o usuário sem uma direção
ou comparação, entretanto, oferecemos algumas sugestões gerais, que podem ou não funcionar para sua impressora 3D.

* Velocidade de perímetro: 60 mm/s
* Velocidade de perímetro pequeno: 20 mm/s
* Velocidade de primeira camada: 20%
* Velocidade de travel: 100 mm/s
* Velocidade de infill: 70 mm/s
* Velocidade de pontes: 80 mm/s
* Velocidade de _overhangs_ (somente no software repsnapper): 20 mm/s
* Aceleração: 1000 mm/s^2^ nos eixos X e Y, 3000 mm/s^2^ para as impressoras 3D mais robustas, especialmente CoreXY e semelhantes.
* Jerk X/Y: 20 mm/s
* É importantíssimo lembrar que você deve _decidir_ quem cuida de sua aceleração, ou o fatiador ou o firmware! Se as acelerações
forem configuradas no fatiador, o ideal é aumentar ao máximo no firmware (digamos, 10000 mm/s^2^) para minimizar
as interferências. O mesmo vale em relação ao _jerk_ e velocidades máximas.

*Jerk* -- elaborando um pouco mais sobre o que esse ajuste significa, ele é a _máxima_ mudança de velocidade que o
hardware da impressora consegue fazer "instantaneamente", sem precisar usar as acelerações. Considera-se então
que no intervalo do jerk o hardware tem aceleração infinita, ideal. Como o jerk é uma mudança de velocidade,
ele é dado em mm/s. Diferente de outros ajustes, ele é uma quantia __vetorial__, onde o ângulo conta. Por isso
existem ajustes separados de jerk para cada eixo (alguns firmwares e fatiadores juntam os ajustes de X e Y em um
só, visto que frequentemente os dois eixos têm as mesmas velocidades e características físicas), incluindo o
"eixo" virtual do extrusor, ou seja, a velocidade de extrusão.

Como a _direção_ conta, isso quer dizer que até mantendo a velocidade escalar constante, mas mudando a direção,
o ajuste de _jerk_ pode entrar em ação.

[[comofuncionaojerk]]
image::comofuncionaojerk.png[comofuncionaojerk,width=642,height=648,align="center",title="Caso de mudança de direção em que um jerk configurado como 20 mm/s é excedido. A velocidade escalar se mantém constante, mas as duas velocidades em X e Y têm mudanças diferentes. A mudança de velocidade no eixo X foi de apenas 8mm/s (60 para 52 mm/s), mas no eixo Y foi de 30mm/s, maior em valor absoluto que 20mm/s de jerk (esse valores de velocidade podem ser calculados usando seno e cosseno do ângulo). Como a velocidade final excede o jerk, as configurações de aceleração serão aplicadas e o extrusor demorará mais para percorrer essa trajetória. Se o jerk fosse de 31mm/s nesse caso, o firmware consideraria que o hardware da impressora consegue fazer este movimento instantaneamente, e não aplica acelerações."]

Colocando um jerk *alto* (digamos, 30 ou 40mm/s), você está dizendo para o seu fatiador ou firmware que o hardware
da sua impressora é de qualidade industrial e muito próximo do ideal, não gerando artefatos com esse valor. Com
o jerk *baixo* (digamos, 5 ou 10 mm/s), você está dizendo que a sua impressora não aguenta fazer mudanças
de velocidade e direção muito bruscas e precisa das configurações de aceleração atuando. Geralmente quando
você tem artefatos de líquido derretido espirrando ou de efeito de ziguezague horizontal ("ringing"), você
vai querer diminuir seu jerk.

Algumas traduções da palavra jerk seriam "impulso", "arranque", "empurrão" ou "puxão". Este
é um caso em que se pesou que tais palavras mais confundiriam que esclareceriam o termo e se optou por usá-lo
no original em inglês, como jargão técnico.

[NOTE]
.Nota
====
Existe um conceito de _jerk_ da física que não é o mesmo jerk que conceituamos. Traduzido como
"arrancada", o jerk da física designa a taxa de variação da aceleração, assim como a aceleração designa
a taxa de variação da velocidade e a velocidade é a taxa de variação de posição. A unidade deste _jerk_ é
distância por tempo ao cubo (e.g. 1000 mm/s^3^), enquanto que a do ajuste do fatiador ou firmware é em distância
por tempo (e.g. 20 mm/s).
====

[TIP]
.Autospeed do Slic3r
====
há um ajuste especial do Slic3r que, tendo em vista as equações de Bernoulli para
fluidos, tenta reajustar as velocidades e extrusão enquanto imprime de forma a manter a pressão dentro do hotend a
mais constante possível, garantindo uma qualidade e consistência maiores e também largamente diminuindo a chance
de falhas por mudanças bruscas durante a impressão (especialmente por retração). É especialmente importante
para a extrusão com filamentos flexíveis. Para que este ajuste funcione, basta colocar uma velocidade máxima de
extrusão em Print Settings → _Speed_ → _Autospeed (advanced)_ → _Max print speed_ e deixar um "zero" nas
velocidades da mesma seção que se deseja que o algoritmo trate (velocidades de suportes, pontes e preenchimentos
de vãos não são tratados pelo algoritmo).

[[autospeedslic3rtip]]
image::autospeedslic3rtip.png[autospeedslic3rtip,width=490,height=699,title="Autospeed do slic3r, recurso para deixar a extrusão mais suave e consistente e indispensável para o uso com filamentos flexíveis. Com os 6 primeiros ajustes de velocidades em zero, a autospeed decidirá a velocidade ideal para todas essas ocasiões. Para ser ainda mais exato, é possível limitar também a velocidade volumétrica máxima de filamento extrudado mas não estritamente necessário."]
====

=== Retração

Já mencionamos retração antes, agora vamos explicar o conceito: quando o hotend está extrudando filamento na
peça e precisa fazer um movimento de "travel", isto é, se mover no plano XY sem realizar nenhuma impressão,
se ele iniciar o movimento imediatamente o filamento líquido que está no bico não pára imediatamente de escorrer,
e formará um "fiapo" de plástico que ficará agarrado na superfície de onde o bico sai. Esse efeito tem o
nome de "stringing" e é um dos artefatos possíveis de filamento pouco viscoso.

Existem várias formas de impedir ou amenizar este efeito, e a forma mais efetiva é o movimento de retração:
assim com o extrusor traciona o filamento para a frente, o movimento rápido para trás cria um vácuo que recolhe
todo o filamento derretido novamente para dentro do bico. Essa é a retração, um recurso tão efetivo que está
presente em todos os fatiadores, mesmo os mais simples, com dois ajustes principais: a velocidade de retração
(geralmente entre 20-60 mm/s, menos que isso não gera o efeito de vácuo desejado) e quantos mm de filamento o
tracionador deve recolher (geralmente entre 2 e 5mm para extrusores diretos e até cerca de 8mm para extrusores
em bowden).

Logo de cara, existe um problema com a retração. O plástico na zona aquecida do hotend está se expandindo com o
calor, e isso não é problema se ele está sendo levado para a frente, para ser extrudado. Mas se ele for puxado
muito para trás, e tiver uma "folga" maior nessa região como acontece na maioria dos hotends, ele tenderá
a se expandir no volume disponível. Ao ser novamente tracionado para a frente, já expandido e solidificado,
ele não consegue passar pela seção do tubo que leva à zona aquecida, pois está estreito demais pra ele. O
resultado é entupimento e desgaste do filamento na engrenagem do tracionador. Estima-se que 2 segundos fora da
zona aquecida são o suficiente para o filamento expandir o suficiente para entupir, antes de ser tracionado novamente.

[[efeitoderetracao]]
image::efeitoderetracao.png[efeitoderetracao,width=539,height=342,align="center",title="Uma ponta de filamento ABS azul de 3mm e filamento ABS rosa de 1,75mm que foram simplesmente retirados do extrusor. Veja como estão expandidos nas pontas; essa é a região que estava na zona aquecida."]

Algumas estratégias são usadas para diminuir este efeito:

* Deixar o filamento retraído o mínimo possível de tempo é uma delas, e isso se consegue com altas
velocidade de __travel__.
* _Lift Z_ (levantar o extrusor no eixo Z no movimento de retração, e baixar
novamente quando for para outra ilha de impressão) é bastante usado nas impressoras que têm o eixo Z rápido,
como as deltas.
* Também é útil conhecer bem as medidas do hotend para colocar somente o mínimo possível
de retração que não saia da zona crítica de expansão do
tubo interno. Um hotend convencional costuma medir entre 50 a 70mm, com a zona aquecida tendo de 10 a 15mm (20mm
em hotends especializados como o __Volcano__) e o heatbreak cerca de 5mm.
* A _desengrenagem_ ("coasting", presente no Cura e no Simplify3D) é um recurso que pára o filamento décimos de milímetros antes do término da
extrusão, deixando o escorrimento completar o filete para então realizar uma retração menor e menos arriscada.
* O __pressure advance__ (avanço de pressão) do Slic3r é um algoritmo mais avançado e mais difícil de entender e
calibrar mas que também pode contribuir, prevendo a diminuição súbita de pressão e permitindo o escorrimento para
extrusão.
* O _autospeed_ já citado, mantendo a pressão constante, minimiza os escorrimentos e a necessidade
de retração.
* O __combing__, que traduzindo seria algo como "penteamento", é uma estratégia que faz
com que o extrusor ao realizar o _travel_ passe por cima do máximo de área já impressa para purgar o filamento
escorrido no interior das peças.
* _Wipe before retract_ (esfregar antes de retrair) é uma forma mais comedida
de combing, fazendo o extrusor se movimentar dentro da seção transversal em que está pra limpar o bico antes
mesmo de realizar a retração.
* Os firmwares de reprap populares Marlin e Repetier Firmware, assim como o
da Makerbot, o Sailfish, têm um algoritmo de controle de pressão chamando de Pressure Advance, Linear Advance
ou Quadratic Advance. Esse recurso configurável ajuda no controle de pressão reduzindo problemas nos cantos e
pontas da peça e são semelhantes ao pressure advance do slic3r. São especialmente importantes para impressoras
3D que usam filamento guiado (bowden), que sofrem mais de escorrimento.
** Documentação do Advance do Marlin:
http://marlinfw.org/docs/features/lin_advance.html[_http://marlinfw.org/docs/features/lin_advance.html_]
** Documentação do Advance do Repetier Firmware:
https://github.com/repetier/Repetier-Firmware/wiki/Hardware-settings-and-print-quality[_https://github.com/repetier/Repetier-Firmware/wiki/Hardware-settings-and-print-quality_]

Além do entupimento, a retração pode ter o efeito de __grinding__, mesmo sem entupimento. A cada vez que os
dentes do mecanismo tracionador pressionam o filamento, deixam marcas. Sucessivas idas e vindas deixam as marcas
cada vez mais fundas, de modo que retrações repetidas no mesmo segmento de filamento podem acabar fazendo com
que ele se desgaste e pare de responder ao tracionamento.

O efeito da retração é especialmente notável em impressões que têm muitas seções transversais pequenas e
finas, como as peças vazadas estilo "voronoi".

Para este problema, não existe solução fácil. O uso dos valores _default_ até que falhem é a estratégia
usada. É importante ao operador da impressora 3D, entretanto, saber que a interrupção da impressão por retração
pode ocorrer até numa impressora muito bem calibrada. Neste caso, ele deve perseguir as estratégias de impedir
que ocorra novamente do seu fatiador predileto.

.Retração "de hardware" ou "de firmware"
se você vir este termo, a acepção é a seguinte: a
retração na maioria dos fatiadores é implementada com os comandos de movimentação convencional do extrusor -
"G0" e "G1". Quando o fatiador suporta retração __de firmware__, ao invés de usar estes comandos comuns
quando for retrair e avançar da retração, ele usa comandos específicos para a retração, "G10" (retrair)
e "G11" (avançar/recuperar da retração). Deixar o firmware cuidar da retração, ao invés do fatiador,
tem algumas vantagens:

* Permite configurar velocidades diferentes para a retração e recuperação;
* Permite mudar estes ajustes
em tempo real, enquanto estiver acontecendo a impressão, refletindo na qualidade dela;
* Se o firmware estiver
configurado para algoritmos avançados de controle de pressão como o Advance, ele pode agir especificamente na
retração já que os comandos são outros, e assim controlar melhor a qualidade da impressão. Note também que
se você habilitar advance __do fatiador__, a retração de firmware pode ter o efeito contrário, fazer ela sair
do controle do algoritmo.

Configurar este recurso depende de o firmware e o fatiador o suportarem. Os firmwares Marlin e Repetir Firmware
atualmente o implementam (o Repetier ainda possibilita ativar um recurso de "auto-retração", em que converte
comandos G1 com extrusão pura para G10 e G11), mas os fatiadores Cura e Simplify3D não suportam esse recurso,
com o Slic3r sendo atualmente o único que o implementa, nas configurações Printer Settings → General → Advanced.

=== Ajuste da costura

A "costura" ou "selo", "seam" em inglês, é a parte da superfície em que o filete de plástico se
junta consigo mesmo, tendo percorrido uma volta. Geralmente, esta junção é "presenteada" com uma pequena
bolha de plástico decorrente de uma mistura de _stringing_ com outros efeitos físicos. Esta junção permite algum
ajuste limitado pelo fatiador: escolhendo _random_ (aleatório), cada perímetro começará em um ponto aleatório,
de modo que as bolhas individuais ficam menos aparentes; e _nearest_ e __aligned__, dois meios de garantir que
os perímetros comecem sempre em pontos alinhados, o que os tornará mais aparentes na forma final mas também
mais fáceis de "limpar" com instrumentos e acabamento. Um algoritmo simples que poderia ser implementado nos
fatiadores e que já existia no fatiador kisslicer em 2013 é o assim chamado __seam hiding__, que faz o começo
e término do perímetro serem um pouco mais pra dentro que o resto, "escondendo" a costura. No mesmo ano, a
Stratasys adquiriu a patente do método nos EUA (patente __US 20130095303 A1__), desencorajando que os fatiadores
de mercado se valham dele. Ler a patente chega a ser perturbador -- eles listam todo e qualquer caso imaginável
de deixar a costura levemente retrocedida, para assegurar que nem algo parecido posser ser feito por outros. A
patente foi aceita mesmo com vários casos documentados de "arte prévia" desta técnica, algo que teoricamente
a invalidaria.^1^ Nas discussões de fatiadores como o slic3r, se optou por não implementar a técnica para evitar
qualquer imbróglio legal.^2^ É o "espaço de idéias" sendo fechado a olhos vistos.

[[seamhidingkisllicer]]
image::seamhidingkisllicer.png[seamhidingkisllicer,width=642,height=695,align="center",title="Mesmo patenteado pela Stratasys, o seam hiding é implementado no fatiador KISSlicer (possivelmente por ter sido implementado antes, ou nunca terem sido acionados pela empresa). Em destaque, a parte da camada em que há um leve retrocesso do filete para impedir bolhas, e os ajustes para configurar este retrocesso."]

[[costuraalinhadaedesalinhada]]
image::costuraalinhadaedesalinhada.png[costuraalinhadaedesalinhada,width=625,height=260,align="center",title="À esquerda: a costura está alinhada, bem aparente mas fácil de remover com um estilete. À direita: a costura é aleatória, com cada bolha sendo menos aparente que o total."]

No Slic3r, o ajuste da costura está em Print Settings → Layers and Perimeters → Advanced → Seam Position. Você
pode escolher entre alinhado, aleatório e "mais perto" (tentará achar uma face com ângulo agudo para esconder
a costura). O Prusa Slic3r oferece ainda a opção "Rear", que é o Y máximo, e por default já implementa
uma forma modesta de __seam hiding__^3^.

[[costuraslic3r]]
image::costuraslic3r.png[costuraslic3r,width=344,height=180,align="center"]

No Simplify3D, o ajuste da costura está em Layers → Start Points. Você pode escolher entre aleatório, otimizar
para velocidade, e mais perto (alinhado) de um ponto definido pelo usuário no plano XY.

[[costurasimplify3d]]
image::costurasimplify3d.png[costurasimplify3d,width=428,height=157,align="center"]

No Cura, o ajuste da costura está em Shell → Z Seam Alignment, e você pode escolher entre aleatório, menor
caminho e mais perto (alinhado) de um ponto definido pelo usuário no plano XY.

[[costuracura]]
image::costuracura.png[costuracura,width=642,height=242,align="center"]

[NOTE]
.Notas:
====
. Este artigo explica o problema do método patenteado pela Stratasys:
http://patents.stackexchange.com/questions/4667/3d-printing-seam-concealment-for-3d-models-patent-application-prior-art-re[_http://patents.stackexchange.com/questions/4667/3d-printing-seam-concealment-for-3d-models-patent-application-prior-art-re_].
Há razões muito fortes para nos preocuparmos com este frenesi por patentes por corporações, num futuro em que
ninguém mais poderá explorar o espaço de idéias -- todo patenteado. Neste contexto, como que querendo nos
remeter de volta às cavernas, representantes da Stratasys declaram que gostariam de ver mais patentes no Brasil,
mesmo de concorrentes. Paulo Farias, diretor-geral da Stratasys no Brasil, chega a declarar que o Brasil ter
poucas patentes é motivo para "se sentir envergonhado" em uma entrevista para o "canaltech" do youtube
em https://www.youtube.com/watch?v=Vk3weOHcHDw[_https://www.youtube.com/watch?v=Vk3weOHcHDw_].
. https://github.com/alexrj/Slic3r/issues/3299[_https://github.com/alexrj/Slic3r/issues/3299_]
. https://github.com/prusa3d/Slic3r/issues/153[_https://github.com/prusa3d/Slic3r/issues/153_]
====

=== Modo Espiral

Quando mencionamos a _prusa calculator_ ao explicar altura de camada, notamos que tipicamente a impressora 3D tem
uma _resolução_ no eixo Z _muito maior_ que a necessária para qualquer impressão que façamos; no exemplo
ilustrado, um passo do motor correspondia a subir ou descer 0,004mm no eixo Z, isso sem considerar que com os
_drivers_ usados em impressoras 3D podemos chegar a 1/32 desse valor -- 125 _nanômetros_ de resolução, que
parecem em algum momento ser "desperdiçados" por usarmos camadas tão maiores que isso. Claro, uma impressão
que usasse camadas de 125 nanômetros não só demoraria anos para completar como provavelmente nem funcionaria
pela quantidade de plástico tão baixa que deveria sair, em nosso mundo real.

Mas uma maneira de aproveitar essa enorme precisão de posicionamento do eixo Z das impressoras 3D é o _modo espiral_
que praticamente todo fatiador do mercado tem. Sendo adequado somente para algumas geometrias específicas --
objetos bojudos com apenas uma "ilha" por camada, cujo interior não deve ser preenchido -, o que o modo espiral
faz é a impressão contínua do contorno da peça, subindo suavemente numa espiral (daí o nome) progressivamente
mais alta, até chegar ao topo. Fica mais fácil entender através da ilustração do fatiamento de um objeto.

[[espiralaplicado]]
image::espiralaplicado.png[espiralaplicado,width=630,height=360,align="center",title="Modo espiral aplicado a um objeto. Toda a impressão do objeto é realizada por um único filete ininterrupto."]

O tipo de objeto que mais se beneficia desse tipo de impressão são __vasos__, por isso este modo também é
conhecido como "modo vaso". O objeto único de geometria simples é um requisito para ele funcionar corretamente;
caso vários objetos ou um objeto complexo estiverem carregados, os fatiadores não avisam que não vão imprimir
numa espiral ininterrupta -- ao invés disso, eles simplesmente imprimem em camadas, sem espiralizar.

[[espiraldoisobjetos]]
image::espiraldoisobjetos.png[espiraldoisobjetos,width=619,height=451,align="center",title="2 cilindros carregados para fatiar em modo espiral no Simplify3D. Pode-se ver claramente que não há mais espiral, pois o fatiador é obrigado a alternar entre duas "ilhas" de impressão, e já não pode imprimir tudo em um filete só."]

Uma exceção à regra é o Slic3r, que não fatia com o modo espiral ligado se houver mais de um objeto na mesa
-- e deixa a seguinte mensagem na barra de status, até que o problema seja resolvido:

[[espiralavisoslic3r]]
image::espiralavisoslic3r.png[espiralavisoslic3r,width=499,height=26,align="center"]

"Spiral Vase" é o nome da opção nesse fatiador e está nas configurações de camada. Quando você ativa
o modo, ele avisa que vai mudar várias outras configurações e pede confirmação que deseja prosseguir:

[[espiralslic3rconf]]
image::espiralslic3rconf.png[espiralslic3rconf,width=570,height=544,align="center",title="O Slic3r te dá a chance de voltar atrás caso você ative o modo espiral ("Spiral Vase") por engano. Ele também diz os ajustes que vai mudar: colocar parede de um perímetro, remover a camada de topo, mudar o preenchimento para zero, desativar estruturas de suporte e desativar o ajuste de "preenchimento quando necessário"."]

[[espiralsimplify3dconf]]
image::espiralsimplify3dconf.png[espiralsimplify3dconf,width=559,height=422,align="center",title="O Simplify3D também coloca a opção nas configurações de camadas, mas a chama de &quot;modo de impressão de rosca de contorno único ou modo vaso&quot;. De início ela não muda os outros ajustes até que você peça para ocorrer o fatiamento."]

[[espiralsimplify3daviso]]
image::espiralsimplify3daviso.png[espiralsimplify3daviso,width=449,height=178,align="center",title="Quando se chama o fatiamento, o Simplify3D avisa que como o modo espiral está ligado, ele vai mudar automaticamente os outros ajustes."]

[[espiralcuraconf]]
image::espiralcuraconf.png[espiralcuraconf,width=642,height=570,align="center",title="O Cura chama a opção de &quot;espiralizar contorno externo&quot; e a tem na seção &quot;modos especiais&quot;, ao invés de configurações de camada. Se a opção for selecionada ele simplesmente muda os ajustes necessários, assumindo que o usuário tenha lido a dica de ajuda (balão azul) que apresenta e não pedindo confirmação."]

Por causa da maneira como o modo espiral funciona, com a camada superior sendo automaticamente removida, muitos
objetos em sites de compartilhamento de designs como o thingiverse deixam para download o contorno sólido do
"vaso", assumindo que o modo espiral automaticamente o deixará aberto em cima. Um exemplo é a série de
vasos "Julia" do thingiverse (Julia é o nome dado a um conjunto de fórmulas matemáticas fractais):

[[vasojulia]]
image::vasojulia.png[vasojulia,width=642,height=428,align="center",title="Vaso Julia. Disponível em http://www.thingiverse.com/thing:126567"]

O modo vaso é especialmente útil para quem usa bicos largos (digamos, maiores que 0,8mm).

=== Ajustes especiais de qualidade

Cada fatiador tem suas peculiaridades, analisamos aqui alguns dos recursos específicos de cada um:

.Slic3r
Em _Print Settings_ → _Layers and perimeters_ há o quadro "__quality__" com 4 opções
liga/desliga:

[[slic3rconfqualidade]]
image::slic3rconfqualidade.png[slic3rconfqualidade,width=577,height=139,align="center"]

* *Extra perimeters if needed* (perímetros extras se necessário) -- em superfícies inclinadas, uma configuração
baixa de perímetros (paredes) pode, através do arredondamento, acabar expondo a parte interna da peça. Com
este ajuste ligado, o fatiador "arredonda pra cima" e coloca paredes a mais para garantir fechamento da peça.
* *Avoid crossing perimeters* (evitar cruzar perímetros) -- modifica a trajetória do extrusor de modo que ele
procure ficar tão na parte interna da peça quanto possível, economizando _travels_ e __retrações__.
* *Detect thin walls* (detectar paredes finas) -- paredes com espessura próxima da largura de extrusão podem sofrer um
arredondamento indevido e acabarem mais grossas do que deviam ou ainda com um "espaço" entre duas passadas do
extrusor. Ligar este ajuste faz o fatiador detectar tal situação e corrigir, tanto preenchendo o espaço quanto,
quando necessário, realizando passada única. Se ainda assim os espaços aparecerem, um outro jeito de corrigir é
ir em Print Settings → Advanced, seção __Overlap__, e aumentar o valor (por default é 15%). Overlap significa
"sobreposição", e é uma porcentagem que diz em quanto o preenchimento "penetra" nas paredes, para não
ficarem como peças separadas.
* *Detect bridging parameters* (detectar parâmetros de ponte) -- já falamos
das pontes; com este ajuste ligado, o Slic3r analisa a geometria do objeto para saber quando usar as pontes,
se estiverem ativadas.

Todos os ajustes são recomendados. A razão de eles serem opcionais é devido ao histórico de lentidão do
fatiador que felizmente tem sido corrigida a cada nova atualização, e o impacto de cada um desses ajustes diminui
igualmente no tempo de fatiamento.

Um ajuste adicional de qualidade do Slic3r que vale a pena ser citado, ainda, é o de "resolução"
(__*Resolution*__), que fica em Print Settings → Advanced → Other. No campo você coloca um valor em milímetros
que ele considerará como sendo o lado do "pixel" volumétrico, ou __voxel__, da peça a fatiar. Qualquer
detalhe menor que essa medida será automaticamente simplificada. O _default_ desse campo é zero, quer dizer,
o fatiador usa toda a resolução da peça. Se o fatiamento estiver demorado, colocar um valor nesse campo pode
ser um jeito de o acelerar. Também ajuda a evitar que durante a impressão o extrusor fique com o que parece
"excesso de esmero" em algumas seções pequenas, extrudando pouco e dando "pulinhos"; isso é sintoma de
peça excessivamente detalhada.

.Simplify3D
Os ajustes específicos de qualidade do Simplify3D ficam espalhados por sua configuração,
mas a maioria deles é na aba __Advanced__.

* Comecemos por eles, então, na seção de _thin walls_ (paredes finas):
+
[[simplify3dthinwallbehavior]]
image::simplify3dthinwallbehavior.png[simplify3dthinwallbehavior,width=441,height=136,align="center"]
+
O ajuste é bastante semelhante ao _detect thin_ walls
do Slic3r: desligado ("Only use perimeters for thin walls") ou ligado, com a tolerância de sobreposição de
um perímetro em cima do outro definida. Assim como no Slic3r, se mesmo com esse valor algumas brechas aparecerem,
você deve ir na aba "Infill" e aumentar o valor do "Outline overlap" (default em 20%).
* *Controle de escorrimento*
+
[[simplify3doozecontrol]]
image::simplify3doozecontrol.png[simplify3doozecontrol,width=425,height=177,align="center"]
+
Este ajuste trata de modificadores para o movimento de retração do final de uma extrusão.
+
** O primeiro ajuste, ☑ __**Only retract when crossing open spaces**__, faz com que ele só execute a retração se não for passar em alguma parte já impressa do objeto;
senão, ele conta para essa parte remover qualquer resíduo do bico.
** O segundo, ☑ __**Force retraction between layers**__, faz com que sempre haja retração quando o fatiador mudar de camada.
** __**Minimum travel for retraction**__ é um ajuste útil para evitar que o tracionador "coma" o filamento fazendo com que avance e
retroceda várias vezes; estabelece uma distância mínima que tenha que percorrer sem extrudar para que a retração
possa ser acionada. Aconselha-se colocar um valor entre 3 a 10mm aqui se suas impressões têm falhado em figuras
rebuscadas como as peças "voronoi". A contrapartida é que mais "verrugas" ou fiapos devem aparecer.
** ☑ __**Perform retraction during wipe movement**__ faz com que, quando for executar um movimento de "wipe"
(passar o bico em áreas impressas para limpá-lo), ao invés de executar primeiro uma retração com o bico parado
e então percorrer o espaço impresso, ele faça os dois movimentos ao mesmo tempo.
** ☑ __**Only wipe extruder for outer-most perimeters**__ faz com que o fatiador não tente fazer o "wipe" para os perímetros mais internos,
visto que não estarão à mostra e suas imperfeições não interferem muito. É interessante deixar esse ajuste
ligado, a exceção seria para filamentos translúcidos e transparentes, em que essas imperfeições podem importar.
* Note que estes ajustes usam bastante o movimento de "wipe" e por isso o próximo ajuste,
"☐ __**Avoid crossing outline for travel movements**__", não deve ser ligado, pois faria o fatiador priorizar percursos sem
passar por partes impressas.
* O Simplify3D tem as configurações bastante desorganizadas, e as de retração não
se resumem a essa. Na aba "others", há mais ajustes, pertinentes ao caso de vários extrusores (tools):
+
[[simplify3dtoolchangeretraction2]]
image::simplify3dtoolchangeretraction2.png[simplify3dtoolchangeretraction2,width=429,height=157,align="center"]
+
São eles a quantidade de filamento a retrair,
a quantidade adicional a extrudar quando recomeçar (que aconselhamos deixar sempre em zero) e a velocidade da
retração.
* Por fim, o último lugar onde se configura retração no Simplify3D é na aba "Extruder". Essas
são as configurações principais de retração:
+
[[simplify3doozecontrol2]]
image::simplify3doozecontrol2.png[simplify3doozecontrol2,width=618,height=200,align="center"]
+
** __**Retraction distance**__ e __**extra restart distance**__ são os mesmos do tool change, mas para o caso geral.
** __**Retraction vertical lift**__, também chamado Z-hopping, é levantar brevemente o extrusor quando houver
retração para diminuir a formação de verrugas. Envolve movimento Z do extrusor que costuma ser lento em
cartesianas, sendo mais recomendado para deltas ou no mínimo cartesianas mais rápidas. A velocidade é configurada
no próximo ajuste, __**Retraction Speed**__.
** __**Coasting**__: como já mencionamos, coasting ou _desengrenagem_
é o tracionador deixar de tracionar alguns décimos de milímetros antes do fim da extrusão, para que o filamento
escorrido de excesso seja totalmente consumido. 0,20mm, o default do Simplify3D, é uma quantidade boa para o caso
geral.
** __**Wipe**__ é o movimento de limpeza do bico passando em cima de áreas impressas, ou seja, uma espécie de
__combing__. Ligando-se esse ajuste o fatiador passa a procurar realizar o wipe depois de completar o perímetro
de uma ilha impressa, e o wipe distance é a distância que ele deve percorrer realizado o movimento. Se
__**perform retraction during wipe movement**__ estiver ligado, a distância aqui não é usada, sendo usada a duração da
retração no lugar. O _wipe_ só é executado se a mínima distância para retração tiver sido percorrida.
* __**Bridging**__
+
[[simplify3dbridging2]]
image::simplify3dbridging2.png[simplify3dbridging2,width=424,height=211,align="center"]
+
Antigamente bastante deficiente tanto
na detecção quanto na configurabilidade de suas pontes, a versão 4.0 do Simplify3D trouxe boas melhorias nessa
parte. Os ajustes são:
+
** __**Unsupported area threshold**__: quanto de área mínima sem suporte é necessária
para que o algoritmo decida que vai usar a estratégia de "ponte" para ligar uma seção à outra. Dada em
milímetros quadrados (mm^2^).
** __**Extra inflation distance**__: este ajuste leva em conta que a região de
suporte da ponte se apóia em determinadas camadas inferiores (mais interna que as paredes), e permite expandir
a região usada como apoio pra permitir uma fundação mais sólida. Pode ser difícil visualizar, então aqui
está um exemplo de uma ponte expandida em 2mm
+
[[simplify3ddistinflacao2]]
image::simplify3ddistinflacao2.png[simplify3ddistinflacao2,width=594,height=282,align="center"]
+
** __**Bridging extrusion multiplier**__ e __**bridging speed multiplier**__: assim como no Slic3r, estes multiplicadores
de extrusão e velocidade permite que durante a ponte o fatiador extrudem menos plástico e mais rapidamente,
para que ele fique mais esticado.
** __**Use fixed bridging infill angle [0] deg**__ -- faz com que os filetes que
percorrem a ponte tenham um ângulo diferente de 0 graus (paralelo à direção da ponte).
** __**Apply bridging settings to perimeters**__ -- ao invés de considerar a ponte como somente a parte interna da estrutura que liga
duas ilhas, considera seus perímetros como parte dela.
+
[[simplify3dapplybridgingper2]]
image::simplify3dapplybridgingper2.png[simplify3dapplybridgingper2,width=642,height=473,align="center",title="Ponte com &quot;apply bridging settings to perimeters&quot; selecionado - as camadas externas passam a ser consideradas parte dela. E com 20 graus de ângulo no &quot;fixed bridging infill angle&quot;."]

.Cura
Os ajustes relacionados a qualidade de impressão no Cura são tantos que fica difícil selecioná-los. Por
isso, selecionamos os mais semelhantes ao slic3r e simplify3d, referentes a perímetros, parede finas e
retração. Como arremate, vamos mostrar a mesma seção em inglês e português, para que a equivalência seja
conhecida. O Cura já apresenta "dicas" em azul com a descrição do que a configuração faz -- traduzidas
para português em sua versão oficial do programa pelo autor deste livro -, portanto a explicação aqui envolverá
mais do que isso.

[[curashell2]]
image::curashell2.png[curashell2,width=642,height=232,align="center",title="Seção &quot;Shell&quot; ou, em português, &quot;Perímetro&quot; do Cura, alguns ajustes especiais. Se não aparecem no seu Cura, vá nas configurações e veja visibilidade dos ajustes. Os ajustes em inglês à esquerda equivalem aos em português da direita."]

* __**Outer Wall Inset**__ é um ajuste que juntamente com a compensação horizontal, tratada na próxima seção,
ajuda uma peça a ter dimensões mais de acordo com o modelo. No momento do fatiamento ou tradução da peça 3D
para uma trajetória de filetes, as áreas mais externas da peça podem ser "arredondadas para cima", tornando
o objeto um ou dois décimos de milímetro mais largo. Se isso estiver acontecendo, vale a pena ligar esta opção,
que recua o filete mais externo mesmo com ele se sobrepondo ao segundo filete mais externo. Esta opção tem o
risco de deixar a aparência da peça mais rugosa pelo excesso de filamento na superfície.
* __**Outer Before Inner Walls**__ pode ser um jeito de diminuir a rugosidade do ajuste anterior se ela acontece. Basicamente, inverte a ordem
de construção das paredes de um objeto, que é por default de dentro pra fora, para que seja de fora pra dentro,
logo o segundo filete, se sobreposto ao mais externo, será depositado em cima da camada externa já solidificada. Por
outro lado, em seções pendentes, por o filete mais externo ser depositado sem o suporte lateral do filete mais
interior, ele pode acabar tendo menor qualidade.
* __**Alternate Extra Wall**__ faz em camadas alternadas a parede
ter um filete a mais pra dentro. Este filete ajuda a sustentar o suporte interno, reforçando a peça como um todo.
+
[[curaalternarparedeadicional2]]
image::curaalternarparedeadicional2.png[curaalternarparedeadicional2,width=642,height=240,align="center",title="&quot;Alternar Parede Adicional&quot; - Alternate Extra Wall - faz um perímetro interno intermitente que ajuda a &quot;segurar&quot; os filetes do preenchimento interno. As 4 figuras representam camadas sucessivas do fatiamento de um cubo."]
+
* __**Compensate Wall Overlaps**__: em algumas geometrias, o processo de fatiamento calcula uma trajetória de
filete que por vezes tem que passar no mesmo lugar duas vezes -- sobrepondo um filete sobre outro. Embora
na maioria das vezes esse plástico em excesso se acomode bem na geometria, umas poucas vezes ele pode gerar
imperfeições visíveis. O Cura permite diminuir a extrusão ao passar sobre tais áreas de modo que não haja
plástico em excesso nas sobreposições, e você pode até definir se somente nas paredes internas ou externas.
* __**Fill Gaps Between Walls**__: assim como a trajetória do fatiador pode ter sobreposições de filetes, devido
à espessura não desprezível dele o contrário também pode acontecer -- determinadas áreas serem tão pequenas
que as áreas em volta são preenchidas, mas uma "falha" permanece. Ativar este ajuste faz com que no final
da impressão da camada o extrusor volte a esta falha e a preencha com uma "gota" de filamento. O maior revés
desta configuração é o tempo maior de impressão.
+
[[curafillgaps]]
image::curafillgaps.png[curafillgaps,width=642,height=276,align="center",title="Lacuna preenchida com o ajuste &quot;Fill Gaps&quot;. Adaptado para português do material educativo da Ultimaker em https://ultimaker.com/en/resources/20415-shell"]
+
* __**Print Thin Walls**__: Se já entendemos que o algoritmo de fatiamento "arredonda" a trajetória para a forma
desejada visto que a espessura do filete não é desprezível, o ajuste de imprimir paredes finas nada mais faz que
dizer se ele deve arredondar a forma para cima (ligado) ou para baixo (desligado). Se você tem uma superfície
impressa com letras de 0,2mm de espessura mas a largura de extrusão do bico é 0,4mm de espessura, com o ajuste
desligado as letras não vão aparecer. Com o ajuste ligado elas vão aparecer com 0,4mm de espessura. Na seção
seguinte, compensação horizontal, tratamos um caso semelhante resolvido de outro modo.

Vale ainda mencionar mais um ajuste específico no final da seção "perímetro": __**Ignore Small Z Gaps**__,
ou __**Ignore Pequenas Lacunas em Z**__. Esse ajuste vem ligado por default e faz com que se o modelo tem pequenas
reentrâncias na geometria -- como por exemplo uma fenda horizontal de 0,2mm de altura (eixo Z) -- o fatiador
a ignore e a preencha com paredes e preenchimento como se fosse uma parede contínua. Se seu modelo tem detalhes
que necessitam dessas lacunas e o fatiamento não as revela, é por causa disso.

**Retração**: os ajustes principais de retração do Cura ficam na seção "**Material**":

[[curamaterialretracao2]]
image::curamaterialretracao2.png[curamaterialretracao2,width=642,height=265,align="center"]

Mas não todos. Os restantes ficam na seção __**Travel**__ (__**Percurso**__):

[[curatravelretracao2]]
image::curatravelretracao2.png[curatravelretracao2,width=642,height=154,align="center"]

Ao invés de discutir cada ajuste da retração ou reiterar expressões óbvias com "Retrai em Mudança de
Camada", mais vale entendermos as diferenças e semelhanças da retração do Cura com os outros fatiadores. O
que o Simplify3D chama de *wipe* é o que o Cura chamada de *combing* ("penteamento"), ou seja, passar o bico em
área já impressa para depositar filamento escorrido ou resíduos dentro da peça. A "distância extra" que o
Simplify3D extruda depois da retração é equivalente à "__**Quantidade Adicional de Avanço da Retração**__"
(__**Retraction Extra Prime Amount**__), só que dada em _volume_ (mm^3^) ao invés de distância de entrada do
filamento. Se quiser achar o volume _v_ em função do diâmetro _d_ do bico e da distância _L_ do filamento,
a fórmula é:

latexmath:[v=\frac{\pi d^2L} 4]

Por exemplo, para extrudar 0,2mm a mais de um filamento de 1,7mm de diâmetro, o volume equivalente é

latexmath:[v=\frac{3,1416\times 1,7^2\times 0,2} 4=0,454\mathit{mm}^3]

Um ajuste útil para peças detalhadas é a contagem máxima de retrações: para evitar que o filamento soja
desgastado pelo vaivém do tracionador quando muitas retrações estão sendo feitas num baixo período de tempo,
pode-se especificar um número máximo (__**Maximum Retraction Count**__) em determinada distância
(__**Minimum Extrusion Distance Window**__) para que ele volte a retrair.

__**Coasting**__: já introduzimos o conceito desta operação e mostramos os ajustes para o Simplify3D, mas o Cura
permite uma configuração mais detalhada da mesma operação:

[[curacoastingfabulous]]
image::curacoastingfabulous.png[curacoastingfabulous,width=642,height=78,align="center"]

Novamente, o Cura privilegia o _volume_ de filamento extrudado ao invés de comprimento, o que é na verdade
tecnicamente mais adequado já que se espera que as impressoras passem a usar extrusão volumétrica. Para
impressoras 3D com aferição dinâmica de espessura de filamento, a diferença de qualidade pode ser grande.

=== Compensação horizontal

Se você já modelava em 3D antes de ter contato com a impressão 3D, pode ter topado com a seguinte situação:
você modela duas peças, uma principal e outra que deve ser encaixar perfeitamente nela. Para obter esta paridade
perfeita, faz uma operação booleana de diferença nas peças, e o vão de uma corresponde exatamente ao relevo
da outra. Manda imprimir em sua impressora 3D e ao tentar encaixar uma peça na outra, a menor simplesmente não
entra. O que está acontecendo?

A resposta é: apesar de o seu fatiador conhecer as dimensões do seu objeto e calcular o fatiamento levando
em conta as dimensões ideais das camadas, o fato de cada filete abaixo ser "espremido" pelo de cima faz as
bordas da peça se _espalharem_ um pouco mais do que o ideal, e traçarem um contorno no plano XY mais largo que
o modelado. Exagerando o espalhamento para ilustração, o que aconteceu com os encaixes foi análogo a isto:

[[compensacaohorizontal1]]
image::compensacaohorizontal1.png[compensacaohorizontal1,width=528,height=442,align="center",title="Representação exagerada do que acontece com as impressões. As peças verdes são os modelos originais, a área amarela corresponde ao que é efetivamente impresso. As camadas nas bordas, sendo achatadas pela de cima, se tornam um pouco mais &quot;grossas&quot; do que deviam. O fator com que isso acontece é grosso modo próximo ao diâmetro do bico -- por exemplo, em um bico de 0,4mm, costuma ser entre 0,1 e 0,2mm. Os encaixes não casam mais em relação aos modelos (verdes) porque ambas as partes estão “expandidas”."]

Uma solução pra isso foi criada primeiro no fatiador slic3r, logo em seguida copiada pelo Simplify3D e um pouco
depois, pelo Cura. Ocorre que as operações-padrão de "inset" e "outset" (termos de computação gráfica)
já são rotineiramente usadas pelos fatiadores em outras áreas, e são delas que precisamos para resolver este
problema. Como elas funcionam? Do mesmo jeito que a forma amarela é uma "outset" do modelo, ou seja, uma
expansão em todas as direções dela, o modelo é, ele mesmo, uma expansão de outra forma mais interna. Basta
calcular esta forma mais interna e fatiá-la no lugar do modelo, pois a expansão dela equivalerá às dimensões
reais dele. Desse modo:

[[compensacaohorizontal2]]
image::compensacaohorizontal2.png[compensacaohorizontal2,width=507,height=469,align="center",title="Agora a forma verde é a forma recalculada pela compensação horizontal. Se nossas formas impressas &quot;engordavam&quot; 0,1mm, por exemplo, precisamos colocar uma compensação horizontal &quot;para dentro&quot;, com sinal negativo: **-0,1mm**. Impressas, essas peças ficam 0,1mm mais grossas, que é o que precisavam para corresponder às formas originais, e se encaixam perfeitamente. É importante notar que isso não ocorreria caso apenas diminuíssemos as peças ao invés de &quot;emagrecê-las&quot;, pois os buracos também diminuiriam, tornando-se mais apertados, e o problema de encaixe e precisão permaneceria."]

O valor de compensação horizontal é obtido pragmaticamente para o bico e filamento estimando-se a diferença
entre encaixes. A compensação horizontal negativa funciona bem para o caso dos encaixes, mas a positiva também
é útil para, por exemplo, letras finas que não aparecem...

[[compensacaohorizontal3simplify3d]]
image::compensacaohorizontal3simplify3d.png[compensacaohorizontal3simplify3d,width=619,height=518,align="center",title="Um jeito simples de corrigir letras finas não aparecendo: mudando-se a compensação horizontal para 0,10mm. Isso também passa uma lição importantíssima que é boa prática para impressão 3D: *sempre* verifique o resultado do fatiamento na pré-visualização antes de mandar imprimir, você pode evitar a decepção no final."]

Como última nota sobre este recurso utilíssimo, cabe notar que os nomes são diferentes em fatiadores diferentes:

* **Slic3r**: Print settings → Advanced → Other → XY Size Compensation
* **Cura**: Shell → Horizontal Expansion
* **Simplify3D**: Other → Horizontal Size Compensation
* **repsnapper**: Preferences → Optimization → Offset Outer Shells By (mm)

=== O problema dos arcos e círculos

Além do "espalhamento" indesejado das impressões 3D que a compensação horizontal ataca, temos também um
outro problema que não raramente é confundido com este espalhamento, pois tende a deixar seções circulares
mais estreitas. Este é na verdade um dos inúmeros aspectos de um problema _milenar_ da humanidade chamado de
"quadratura do círculo"^1^, ou quais os métodos que podem ser usados para transformar a curva do círculo em
um segmento linear. Na engenharia, especificamente na engenharia que criou a impressão 3D, esse problema afeta
as estruturas em arco e circulares, especialmente os orifícios circulares. Na introdução do livro falamos
de _papers não-acadêmicos_ e citamos o célebre post de blog do reprapper _nophead_ que expõe esse problema:
http://hydraraptor.blogspot.com.br/2011/02/polyholes.html[_http://hydraraptor.blogspot.com.br/2011/02/polyholes.html_].

Basicamente, são __**4**__ os problemas que encontramos quando importamos um STL no fatiador, fatiamos e o colocamos
para imprimir:

. **Erros de facetamento**: quando os sistemas de modelagem 3D convertem cilindros em malhas de triângulos
usadas para a impressão, eles produzem um prisma poligonal, ou seja, o círculo é transformado em um polígono
equilátero de muitos lados.
+
image::image403.png[image,width=642,height=500,align="center",title="Um círculo vermelho transformado em um polígono circunscrito (interno) de 10 lados, em azul. Esse processo diminui a área do círculo em cos(π/número de lados). Essa é só uma das técnicas de &quot;tesselamento&quot; de círculos: ele poderia ainda ser circunscrito (externo) ou até intermediário entre um e outro. Com lados infinitos, todos esses polígonos se aproximariam do círculo."]
+
. **Pausas de segmento**: ok, converter um círculo para um polígono com 10 facetas não é boa idéia. Na hora
de imprimir, então, vamos usar o máximo número de segmentos de reta possível -- digamos, 1000 segmentos. E
tentando resolver o primeiro problema, topamos no segundo: as __pausas de segmento__. A impressora vai receber
_centenas_ de segmentos minúsculos pra percorrer, cada segmento extrudando uma quantidade insignificante de
filamento. Além dos erros de arredondamento pelo uso de quantidades tão pequenas, a impressora acaba ganhando
um número enorme de instruções a executar em pouco tempo, e ainda contando acelerações e desacelerações,
acaba fazendo pausas entre elas.
. **Encolhimento de arco**: esse problema acontece quando o seu círculo tem
espessura diferente de zero, ou seja, um círculo de "mundo real". O seguinte diagrama explica o problema:
+
image::image404.png[image,width=642,height=599,align="center",title="Um jeito intuitivo de entender o problema de “encolhimento de arco” dos círculos pequenos nas impressoras 3D. Pegue massinha de modelar e faça um tubo reto com ela, grosso e bem uniforme. Então pegue o tubo e torça pra transformá-lo em um círculo.Você verá que a massa mais para dentro do círculo formará &quot;barrigas&quot; por ser excedente; a parte mais externa do círculo rachará por falta de material. O círculo vermelho pontilhado é o orifício que o arredondamento deveria ter, em teoria. Mas por causa do excesso de material para dentro, ele ficará mais apertado. Se o tubo fosse mais fino esse problema não seria muito perceptível pela menor diferença entre os lados internos e externos, por isso o problema é mais grave em orifícios pequenos, próximos à espessura do filete de impressão."]
+
. **Corte / repuxo de cantos**: enquanto que os problemas anteriores eram mais geométricos, este tem mais a ver
com propriedades físicas como viscosidade, aderência, elasticidade e até calor específico. Quando o _hotend_
deposita filamento em uma trajetória reta, e de repente sofre uma mudança suave de ângulo, o filamento acaba
sendo "puxado" dos cantos para dentro. Mais um fator que diminui furos!
+
image::image405.png[image,width=619,height=451,align="center",title="Efeito do &quot;corte de cantos&quot; de filamento extrudado (exagerado para visualização). Mostrada a trajetória do hotend em preto e a deposição do filamento azul na prática. Se estivéssemos extrudando o decágono da divisão do círculo em 10 segmentos retos, estaríamos na verdade imprimindo o círculo inscrito a ele!"]

.Como corrigir esse problema?

Vimos que esse é um problema com causas compostas e bem diversas -- geométricas, físicas, até afetadas por
outros ajustes como compensação horizontal e arredondamento de paredes externas no fatiamento. É, por natureza, um
problema difícil de realmente "resolver" -- sendo melhor a abordagem de _mitigação_ ou __compensação__. No
próprio post de __nophead__, ele propõe uma solução que funcionou bem pra ele: a partir de 2mm de diâmetro,
dividir o círculo em pelo menos duas vezes seu diâmetro em mm. Um círculo de 6mm de diâmetro funcionaria
razoavelmente com pelo menos 12 divisões. Um de 10mm de diâmetro precisaria ter pelo menos 20 divisões.

Essa foi uma regra prática que serviu para o caso dele e lida com dimensões maiores. Infelizmente, não só
não parece muito prática para hoje em dia (em que precisões maiores são exigidas para as peças impressas,
mesmo as de pequena dimensão) quanto exige certo procedimento durante a modelagem, e nem sempre se tem a opção
de mexer na modelagem de um objeto.

**Na prática**: o que é feito é a priorização de modelos tridimensionais com considerável tesselação de
círculos e arcos (mesmo podendo topar no problema das pausas de segmentos) e alguma compensação manual "de
olho" usando configurações de compensação horizontal ou mesmo modelando orifícios maiores. Fatiadores
baseados em manutenção do volume (por __voxels__) como o _Voxelizer_ atacam o problema do ângulo da quantidade
de material utilizado. Pode-se bem dizer que esse é um __problema não resolvido__ da impressão 3D FFF.

.Uma proposta de mitigação mais informada.

Que fique claro que a proposta apresentada aqui é uma incursão espinhosa em uma área controversa. Depende ainda
de softwares não totalmente adaptados para isso, embora muito já se tenha feito para tal. Os resultados podem
ser satisfatórios ou decepcionantes.

Na parte de malhas, já explicamos que modeladores sólidos costumam usar formatos complexos (STEP, IGES e outros)
que incorporam "curvas reais", determinadas por fórmulas matemáticas, mas que as malhas comumentes usadas nos
fatiadores de impressão 3D FFF não gozam dessa facilidade. É até possível que em algum futuro suas bibliotecas
internas ganhem suporte a curvas matematicamente formuladas e possam passar tal informação ao fatiamento, mas no
momento nenhum deles tem isso. No entanto, apesar de _fatiadores_ não incorporarem, a surpresa é que a maioria dos
_firmwares_ de mercado já apresenta suporte a curvas reais -- na forma de _arcos_ -- e já vem com esse suporte
ativado por default. Isso vale para Marlin, Repetier e Smoothieware: os comandos pertinentes são os G-Codes `G2`
e `G3`, denotando arco circular na direção horária e anti-horária respectivamente. Outros G-Codes padronizados
nas CNC, mas ainda não implementados nas impressoras 3D, seriam os `G5` e `G5.x`, para _splines_ e __NURBS__.

Em teoria, um firmware que implementa `G2` e `G3` pode, se valendo de tal descrição matemática infinitamente
precisa da trajetória, e conhecendo das particularidades mecânicas e eletrônicas do dispositivo que controla bem
melhor que o fatiador, adequar as correntes, tensões, tempos e forças de forma que a deposição do filamento
seja muito mais suave e precisa, sem pausas ou outros artefatos que causariam os piores efeitos da quadratura de
curvas. Teríamos uma curva de deposição matematicamente muito mais próxima da real.

Mas de que valem o `G2` e `G3`, se as próprias formas que os fatiadores informam, em formatos STL, AMF ou 3MF,
não podem ter arcos? Ora, eles _têm_ formas parecidas com arcos mas que foram transformadas em uma sequência
de pequenos segmentos de ângulos suaves. A questão é: algoritmos matemáticos podem detectar tais sequências
convertidas e recuperar os arcos da forma, produzindo `G2` e `G3` onde necessário. O fatiador repsnapper, por exemplo,
tem esse recurso. Slic3r, Cura e Simplify3D, no entanto, não têm. E ainda que seja interessante conhecer e executar
o repsnapper como prova de conceito, a carência de recursos desse fatiador não justifica usá-lo só por isso.

Mas não é necessário. Essa inferência de segmentos pra curvas pode ser feita _depois_ do fatiamento. De
fato, existe um software externo que, alimentado com G-Code de _qualquer_ fatiador de mercado, infere as curvas
e devolve um G-Code com elas transformadas em arcos `G2` e `G3`. Esse software, livre e multiplataforma,
chama-se **GCode Arc Optimiser**, é escrito em PHP e tem colaboração do autor do livro^2^. Pode ser baixado de
https://github.com/manticorp/GcodeArcOptimiser[_https://github.com/manticorp/GcodeArcOptimiser_]. O software exige
uma versão do interpretador PHP instalada e para ser usado, necessita que um pequeno script seja criado em sua
pasta (pode ser criado por qualquer editor de textos puro e gravado como "cli.php"):

[source,php]
----------
<?php
include "functions.php";

$debug             = false;
$lookahead         = 5;   //
$pos_error         = 0.1; // absolute
$alignment_error   = 0.01; // absolute
$extrusion_error   = 0.15; // percent
$start             = microtime(true);

$options = getopt('f:o:');

$gcode  = str_replace("\r","",file_get_contents($options['f']));
$gcode  = explode("\n", $gcode);
$gcode  = SplFixedArray::fromArray($gcode);

$processed = processGcode($gcode);

file_put_contents($options['o'], $processed);
----------

E então colocar o arquivo G-Code de entrada (digamos, entrada.gcode) na mesma pasta e executar a conversão:

[source,sh]
----------
php cli.php -f "entrada.gcode" -o "saida.gcode"
----------

Verifique a saída no final; deve haver alguma linhas começando com `G2` e `G3`. Os orifícios extrudados com esses
comandos serão mais exatos que outros, e as curvas da peça feitas pelas curvas inferidas serão também mais suaves.

[NOTE]
.Notas:
====
. Tem até artigo na Wikipedia:
https://pt.wikipedia.org/wiki/Quadratura_do_círculo[_https://pt.wikipedia.org/wiki/Quadratura_do_c%C3%ADrculo_]
. Nada muito envolvido, mas o programa de linha de comando do README, que chama a biblioteca
do autor, não funcionava e foi corrigido por quem escreve estas linhas, com o patch em
https://github.com/manticorp/GcodeArcOptimiser/pull/3[_https://github.com/manticorp/GcodeArcOptimiser/pull/3_].
====

=== Filamentos flexíveis: como imprimi-los

Filamentos flexíveis são um assunto contencioso nas comunidades online de impressão 3D. Sendo motivo de orgulho
para alguns, é alvo de ostentação, subjetividade e amadorismo do mesmo modo que a temperatura da mesa para
impressão: o "funciona comigo" é um troféu que alguns exibem após conseguir imprimir um número limitado
de formas simples, sem no entanto esmiuçar como e por quê o conseguiram, muitas vezes com alegações duvidosas
sobre os resultados obtidos e contraditórias à engenharia envolvida.

.Causas da dificuldade

Entender o que torna as diversas marcas e tipos de filamento flexível difíceis de imprimir em uma impressora 3D
convencional é o primeiro passo para resolver o problema.

* **Existem diversos tipos de filamento flexível, com diferentes níveis de flexibilidade e propriedades**. De fato,
tudo o que um filamento precisa para ser considerado "flexível" é ser dobrado e voltar à forma original
sem marcas. Nessa classificação entram filamentos quase rígidos de poliuretano mas também termoplásticos
elastômeros suaves e molengas, entram filamentos de suporte que aderem facilmente à mesa como PVA e filamentos
de alta temperatura que sofrem warp e resistem à aderência como nylons. Tendo como única característica comum a
elasticidade, é fácil perceber que certa estratégias para uns pode falhar para outros. Em especial, os seguintes
problemas são derivados desta variabilidade:
** A maioria dos filamentos flexíveis **adere bem à mesa**, sem
precisar nem mesmo de cola ou mesa aquecida, e não sofre warp. Para filamentos que usam nylon, geralmente é o
contrário -- cola e mesa aquecida são fundamentais, não só o arranjo no extrusor.
** O bom tracionamento
de um filamento flexível específico depende de um *equilíbrio delicado de pressão no tracionador* que se for
baixa, não consegue penetração dos dentes no filamento para tracioná-lo, e se for alta, leva ao ovalamento
do filamento que gera entupimentos e aumenta a chance de o filamento embolar. O equilíbrio será diferente para
cada filamento, e alguns extrusores nem mesmo têm ajuste dessa pressão.
* *Embolamento do filamento nos vãos logo após o tracionador* são o acidente mais comum nas tentativas de impressão com filamento flexível. Como a
tendência de um fio flexível ao ser impelido para a frente pelo tracionador mas enfrentar resistência mecânica
é se flexionar ao invés de repassar a tração para a frente, qualquer folga ou reentrância que permite que
este fio acomode sua forma para a flexão fará com que ele se dobre, e a partir de uma dobra inicial ele já perde
toda a tração subsequente. Poucos mecanismos tracionadores têm espaçamento apertado o suficiente para impedir
que isto aconteça e mesmo o tubo por onde entra o filamento flexível para ir para a área quente tem que ter
baixo atrito e bem justo (o que se contrapõe ao uso de tubos mais espaçosos para funcionar bem com variações
de diâmetro de filamento).
+
[[videoadaptacaoextrusorflexivel]]
image::videoadaptacaoextrusorflexivel.png[videoadaptacaoextrusorflexivel,width=642,height=466,align="center",title="Um dos melhores vídeos de adaptação de um extrusor para funcionar bem com filamento flexível do youtube mostra como o filamento flexível &quot;embola&quot; na folga mínima que existe entre o tracionador e o tubo de entrada em um clássico extrusor Greg's Wade. https://www.youtube.com/watch?v=BZSo7CT914Y"]
+
* *Velocidades altas* compõem a chance de embolamento, pois tracionam maior quantidade de filamento com tendência a
dobrar numa unidade de tempo, com a mesma resistência mecânica.
* *Mudanças de velocidade, ou seja, acelerações*
também se compõem ao problema, pois é nos súbitos inícios e términos de tracionamento que os filamentos
flexíveis mais se curvam, já que ocorre a mudança de pressão rápida. Em especial, as **retrações**, que
são quando o filamento está em pressão constante para a frente, para ser subitamente parado e esticado para
trás, para então ser novamente tracionado pra frente, são os eventos com maior chance de embolamento, **mesmo
que as velocidades envolvidas sejam baixas**.
* *Stringing (fiapos)* são problemas constantes nas impressões com
filamento flexível. Isso ocorre tanto por o filamento flexível ter um escorrimento menos controlável quanto por as
estratégias que melhor mantêm extrusão se contraporem aos mecanismos de controle de fiapos (como a retração).
* *Subextrusão* é outro problema possível dos filamentos flexíveis __mesmo quando se tem um extrusor adequado
sem folgas__, podendo ocorrer tanto por ajustes de fatiamento quanto por perdas de pressão de tracionamento,
especialmente em impressões longas. Parte disso acontece por causa de pequenos fragmentos do filamento que se
acumulam nos dentes e passam a funcionar como se fossem um lubrificante sólido.
+
[[exemplodesubextrusaoflexivel]]
image::exemplodesubextrusaoflexivel.png[exemplodesubextrusaoflexivel,width=642,height=467,align="center",title="Subextrusão que ocorreu em uma peça já perto do final da impressão, numa impressora 3D com extrusor adaptado para filamento flexível. A perda da tração progressiva acabou impedindo a impressão de terminar; eventualmente, o filamento entupiu no tubo."]

.Soluções e mitigações

Entendido e caracterizado o problema, essas são as mitigações que se pode fazer para imprimir melhor com
filamento flexível:

* **Usar um extrusor sem folgas e sem atritos após o mecanismo de tracionamento**. Este é, de longe, o fator
mais importante. De nada adiantam todos os outros esforços se o filamento continua podendo embolar. Na maioria
dos casos, isso envolve trocar todo o extrusor por um outro modelo ou ter que modificá-lo bastante, como no
vídeo citado. Existem extrusores de mercado específicos para lidar com filamentos flexíveis e acopláveis à
vários modelos de impressora, como o __Flexion Extruder__, que tem até mecanismo de autolimpeza para impedir
que a engrenagem acumule fragmentos de filamento que prejudicariam a tração.
+
[[flexionextruder1]]
image::flexionextruder1.png[flexionextruder1,width=642,height=332,align="center",title="Flexion extruder, feito especificamente para filamentos flexíveis. https://flexionextruder.com/ Thomas Sanladerer fez uma análise do extrusor em seu canal do youtube: https://www.youtube.com/watch?v=I0kFA9OIJL0"]
+
Pode não ser necessário comprar um extrusor novo: existem vários modelos imprimíveis,
com uma busca no site _thingiverse_ retornando mais de 500 modelos diferentes:
https://www.thingiverse.com/search?q=flexible+filament+extruder[_https://www.thingiverse.com/search?q=flexible+filament+extruder_]
* *Dependendo do extrusor, pode ser suficiente uma pequena modificação* para eliminar a folga. Tal modificação
será uma peça impressa que se encaixa na folga do extrusor e permite que o filamento escape.
+
[[antigapsethi3d]]
image::antigapsethi3d.png[antigapsethi3d,width=530,height=394,align="center",title="Eliminador de folga do extrusor da impressora brasileira Sethi3D AiP A3, disponível em https://www.thingiverse.com/thing:1017277"]
+
* **Uma das modificações mais efetivas, que pode geralmente ser utilizada em conjunto com uma peça antigap, é a inserção de um tubo de PTFE até o hotend**. O tubo de PTFE é uma peça comum e fácil de ser encontrada na
impressão 3D, visto que é usada em bowdens e no tubo de hotends. É bem justa para o filamento, tem baixíssimo
atrito e pode ser facilmente cortada com uma navalha para ficar bem rente às engrenagens tracionadoras. Muitos
modelos de extrusores para filamentos flexíveis já exigem o uso do tubo de PTFE, mas ele pode ser facilmente
adaptado alargando-se o tubo de saída do tracionador para seu encaixe.
+
[[tubodeptfeextrusor1]]
image::tubodeptfeextrusor1.png[tubodeptfeextrusor1,width=642,height=311,align="center"]
+
* **A distância do tracionador ao hotend deve ser mínima**. Quanto maior a distância, maior a histerese elástica
que impede o tracionamento e favorece o comportamento de "mola". Por isso mesmo, bons extrusores de filamento
flexível são compactos. Pela mesma razão, _bowdens_ costumam ser impraticáveis para uso com filamento flexível,
uma notável exceção sendo o das impressoras _Ultimaker_ que com velocidades baixas consegue imprimi-los -- e
aí a razão de ser uma exceção é por a impressora usar filamento de 3mm de diâmetro, um padrão já em desuso
mas com menor histerese elástica.
* **O aperto do tracionador deve ser regulável**. Como o ponto ideal de aperto
varia de acordo com o filamento flexível usado, com alguns ovalando mais facilmente que outros com o aperto alto,
é desejável que o operador possa experimentar e encontrar o ponto ótimo de aperto. Uma das melhores formas de
se implementar isso é com parafusos reguláveis:
+
[[flexivelparafusosregulaveis]]
image::flexivelparafusosregulaveis.png[flexivelparafusosregulaveis,width=594,height=342,alig="center",title="Parafusos reguláveis que permitem ajuste fino do aperto do filamento."]
+
* Um *tensor de filamento* também ajuda a domar a histerese do filamento flexível, mantendo-o esticado até
a altura do tracionador. É útil porque filamento flácido tende a entrar nas engrenagens mais "de lado" e
portanto a embolar na saída.
+
[[tensordefilamentohisterese]]
image::tensordefilamentohisterese.png[tensordefilamentohisterese,width=571,height=417,align="center",title="Exemplo de um tensor de filamento entre muitos modelos do site thingiverse. https://www.thingiverse.com/thing:692327"]
+
* **Se puder escolher o parafuso tracionador ou pinhão do extrusor, prefira os canaletados ao invés dos retos**. Eles
guiam e aderem melhor a filamentos flexíveis. Por outro lado, isso exige também que a canaleta seja precisamente
alinhada com a saída do tracionador, caso contrário o filamento sofre dobras.
* **A primeira camada não deve
ser muito rente**. Contrariando o que aprendemos sobre fatiamento, no caso do filamento flexível é bom deixar
uma pequena folga na primeira camada. Isso porque a impressão rente deixa a pressão dentro do hotend alta,
e também porque a maioria dos filamentos flexíveis tem excelente adesão à mesa. A exceção notável são os
nylons, que sofrem warp e podem não aderir bem à mesa. A impressão mais alta pode ser feita de diversas formas,
desde colocar o endstop do eixo Z ligeiramente mais alto até mexendo em parâmetros de fatiamento, como o offset
vertical ou altura da primeira camada. +
E em termos de configurações de fatiamento, existem várias estratégias
que podem ser tomada para melhor imprimir com filamento flexível e com menos possibilidades de falhas.

.Nos ajustes de fatiamento:

* *Velocidade de extrusão* é a configuração mais importante para a impressão com flexível funcionar. Uma
velocidade convencional de 60 mm/s geralmente não vai funcionar a não ser com extrusores muito bem preparados
para filamentos flexíveis, filamentos menos exigentes e formas impressas simples. Não acredite nos fanfarrões de
facebook que dizem imprimir Ninjaflex nesta velocidade em impressora com bowden! Comece com uma velocidade pequena
-- digamos, 15 mm/s, ou até mesmo 5mm/s -- imprimindo uma forma simples e vá aumentando à medida que conseguir
confiança que a impressora dá conta.
* *Aceleração do extrusor* também deve ser colocada em um valor baixo para
manter a pressão interna mais constante; um valor entre 200 e 500 mm/s^2^ é recomendado.
* *Retração* deve ser
minimizada. Embora alguns _reprappers_ aconselhem desligá-la totalmente, costuma ser suficiente deixá-la com baixa
velocidade e pequena distância (digamos, 15 mm/s e 2mm de retração). É importante também impedir um número
grande de retrações; neste caso, os ajustes de limitar o número por distância do Cura serão bem úteis, com
20 retrações a cada 10mm sendo o recomendado. Claro que o número de retrações é função da forma impressa,
então formas vazadas, finas e repletas de ilhas como as _voronoi_ terão probabilidade maior de falhar do que
peças inteiriças e grossas.
* No Slic3r, usar autospeed, embora aumente o tempo total de impressão, deixa a
pressão dentro do hotend o mais uniforme possível, diminuindo tanto as chances de falha quanto os artefatos de
impressão, e é altamente recomendada para filamento flexível.
* *Para mitigar o stringing e bolhas, Coasting*
(Simplify3D e Cura) e *Pressure Advance* (Slic3r) ajudam. Colocar uma *velocidade de percurso* (travel) alta, isto
é, a velocidade do carro do extrusor quando não está extrudando, também ajuda. E por fim, habilitar o *Z lift*
(levantamento de Z) quando for necessária uma retração também

== Dupla extrusão

Finalmente, vamos tratar de um dos ajustes que mais quebram a cabeça dos que tratam com modelos que precisam ser
impressos em extrusão dupla. Primeiro, vamos revisitar os quatro formatos principais de arquivos para impressão 3D:

* **STL**: o mais simples, apenas uma malha de triângulos orientados, sem informação de material.
* **OBJ**:
tem informação de material por polígonos e não objetos, e de uma forma mais orientada a visualização. Os
fatiadores não associam essa informação a extrusores diferentes.
* **AMF**: tem informação de material
adequada à impressão 3D, mas só é suportado no Slic3r, sem associação automática de materiais a extrusores diferentes; não funciona no Cura novo e no Simplify3D.
* **3MF**: um formato novo com suporte razoável nos fatiadores. As versões novas de Slic3r, Cura e Simplify3D já abrem esse formato. Ele permite diferentes materiais, mas a atribuição de materiais diferentes a extrusores diferentes não é automática.

Portanto, não há muito jeito de lidar com a dupla extrusão __automaticamente__: sempre é necessário informar ao fatiador que extrusor deve trabalhar com cada parte da peça.

[[freecadamf1]]
image::freecadamf1.png[freecadamf1,width=624,height=526,align="center",title="O FreeCAD como um software de modelagem sólida que já grava em formato AMF - e ao abrir o arquivo, fatiadores como o slic3r oferecem opção para associar materiais diferentes a objetos diferentes, caso estejam em um perfil de dupla extrusão."]

A resposta é que há sim, é perfeitamente possível e até fácil modelar e associar partes de um modelo a extrusor
se você conhece o fluxo de trabalho recomendado para isso. A razão de não ser tão intuitivo com um arquivo
único que resolva todos os problemas é que se a impressão 3D de baixo custo ainda é nova, mais novo ainda é
seu uso com dois ou mais extrusores. O mercado aponta para fluxos mais fáceis e complexos, inclusive com mistura
de materiais, mas por enquanto devemos conhecer a forma "original" de lidar com isso, que envolve arquivos STL -- e essa forma tem a conveniente vantagem de poder ser aplicada de maneira similar aos formatos mais complexos. O procedimento é extensível ainda a mais extrusores (tripla, quádrupla extrusão, etc.).

Mas como se envolve arquivo STL na dupla extrusão, se ele não tem informação de material?

Essa é na verdade quase uma vantagem do arquivo: ele não tem informação de material, então você é quem
deve atribuir essa informação no fatiador. E ele tem informação de coordenadas: se você modela um corpo em
um arquivo, e em outro arquivo você modela uma cabeça cujas coordenadas se encaixam nas exatas coordenadas de
onde aquele corpo acaba, no fatiador eles aparecerão encaixados.

Você precisa informar ao fatiador, no entanto, que ele não deve mudar as coordenadas dos objetos, como por
exemplo os rearranjando automaticamente. No Slic3r, por exemplo, você faz isso pelo menu File → Preferences:
[[slic3rnaoautocentralizar]]
image::slic3rnaoautocentralizar.png[slic3rnaoautocentralizar,width=487,height=358,align="center",title="Deixe desligado o &quot;auto-center parts&quot;, como aparece no diálogo. Ao lado aparecem os dois STLs que temos que se encaixam no mesmo sistema de coordenadas: um cone de tráfego, com as faixas de cores diferentes."]

Abrimos ambos os STLs no Slic3r. Podem ser ambos ao mesmo tempo, um em sequência ao outro, ou arrastando os
arquivos para a janela: eles aparecerão sobrepostos, formando um cone contínuo:

[[osdoisstlsdoconeduplaextrusao]]
image::osdoisstlsdoconeduplaextrusao.png[osdoisstlsdoconeduplaextrusao,width=603,height=516,align="center",title="Os dois STLs do cone, sobrepostos. Note que eles aparecem à direita como objetos diferentes, e as coordenadas casaram. Agora só falta informarmos ao Slic3r que material cada objeto usará."]

Damos dois cliques em qualquer lugar do objeto. O Slic3r tem algo que são os "ajustes individuais por objeto", que
permitem fazer ajustes diferentes para vários objetos na mesa de impressão, como por exemplo infills diferentes. No
nosso caso, estamos querendo associar cada objeto a um material, ou cor nesse caso. Acabamos selecionando a parte
laranja do cone, como a janela mostra:

[slic3rpropriedadesdocone1]
image::image416.png[image,width=439,height=331,align="center"]

Clicamos no sinal de "+" verde abaixo da palavra "Extruder". Aparecerá uma lista desenrolável imensa para
selecionarmos o ajuste específico. Vamos para cima e achamos o "Extruders > Extruder". Ele vem preenchido
com o valor "default". Vemos o painel de materiais do lado e o filamento branco aparece primeiro, o que quer
dizer que está no extrusor 1. Como o material que queremos é o filamento vermelho, selecionamos o extrusor 2.
[[slic3rpropriedadesdocone2]]
image::slic3rpropriedadesdocone2.png[slic3rpropriedadesdocone2,width=572,height=419,align="center"]

Repetimos a operação para o segundo objeto:

[[slic3rpropriedadesdocone3]]
image::slic3rpropriedadesdocone3.png[slic3rpropriedadesdocone3,width=578,height=423,align="center"]

Selecionamos "OK" e pronto, está terminado. O cone será impresso.

No Cura, o fluxo é um pouco diferente. Você importa as duas peças, e ele as dispõe automaticamente; uma vez
importadas, selecionamos a ferramenta "per objects settings", que já mostra de cara a configuração do
extrusor para modificarmos:

[[curaimportamososdoisstls]]
image::curaimportamososdoisstls.png[curaimportamososdoisstls,width=583,height=410,align="center"]

Deixamos a parte selecionada com o primeiro extrusor, selecionamos a segunda parte e mudamos o ajuste para o segundo
extrusor. Agora só falta informar ao Cura que aquelas duas peças estão no mesmo sistema de coordenadas. A
palavra-chave para isso é "merge", misturar. Selecionamos os dois modelos deixando a tecla _shift_ apertada e
clicando em cada um. Então clico com o botão direito em cima e escolho o "Merge Models" (Combinar Modelos, na versão em português):

[[curamergemodels]]
image::curamergemodels.png[curamergemodels,width=580,height=410,align="center"]

Pronto! A visualização já mostra que os modelos estão com cores (extrusores) diferentes:

[[curamodelosemdoisextrusores]]
image::curamodelosemdoisextrusores.png[curamodelosemdoisextrusores,width=581,height=408,align="center"]

Podemos ainda pedir uma "confirmação adicional" fazendo a _boa prática_ de sempre verificar o fatiamento. No
caso do Cura, é clicando no olho e selecionando "Layers":

[[curavisaodecamadasduplaextrusao]]
image::curavisaodecamadasduplaextrusao.png[curavisaodecamadasduplaextrusao,width=597,height=419,align="center"]

Pronto! Fatiamento de dupla extrusão pronto pra ser impresso.

No Simplify3D, o processo é facilitado com o "Assistente de Extrusão Dupla" (Dual Extrusion Wizard), que te guia nos passos. Simplesmente
deixamos ativo o perfil da sua impressora de dupla extrusão e importe os dois STLs. Em seguida, selecionamos **Tools** →
**Dual Extrusion Wizard**:

[[simplify3ddualextrusionwizard1]]
image::simplify3ddualextrusionwizard1.png[simplify3ddualextrusionwizard1,width=601,height=429,align="center"]

No diálogo a seguir, simplesmente escolhemos que objetos serão atribuídos a quais extrusores e selecionamos a opção "group and
align models" para informar que eles estão no mesmo sistema de coordenadas:

[[simplify3ddualextrusionwizard2]]
image::simplify3ddualextrusionwizard2.png[simplify3ddualextrusionwizard2,width=431,height=295,align="center"]

Veremos uma peça que parece de uma cor só, porque a visualização do Simplify3D mostra assim. Mas veja que
o cone aparece inteiriço, o que quer dizer que as duas partes foram colocadas no mesmo sistema de coordenadas.

[[simplify3dposdualextrusionwizard]]
image::simplify3dposdualextrusionwizard.png[simplify3dposdualextrusionwizard,width=558,height=399,align="center"]

Clicamos em "prepare to print" para fatiar, selecionamos as duas cores e veremos o resultado do fatiamento. Ainda não aparecem as
duas cores diferenciadas; para aparecer, teremos que ir no painel à esquerda, "Show in Preview" e selecionar
"Active Toolhead", para que o fatiador diferencie os extrusores ("toolheads") por cores.

[[simplify3ddualdiferenciarmaterial]]
image::simplify3ddualdiferenciarmaterial.png[simplify3ddualdiferenciarmaterial,width=556,height=481,align="center"]

Voilà! Dupla extrusão, exatamente como queríamos.
